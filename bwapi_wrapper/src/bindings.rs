/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_list {
    pub _address: u8,
}
pub type std_list__Base = u8;
pub type std_list__Tp_alloc_type = u8;
pub type std_list__Tp_alloc_traits = u8;
pub type std_list__Node_alloc_type = u8;
pub type std_list__Node_alloc_traits = u8;
pub type std_list_value_type = u8;
pub type std_list_pointer = u8;
pub type std_list_const_pointer = u8;
pub type std_list_reference = u8;
pub type std_list_const_reference = u8;
pub type std_list_iterator = u8;
pub type std_list_const_iterator = u8;
pub type std_list_const_reverse_iterator = u8;
pub type std_list_reverse_iterator = u8;
pub type std_list_size_type = u64;
pub type std_list_difference_type = u64;
pub type std_list_allocator_type = u8;
pub type std_list__Node = u8;
pub type std_list___remove_return_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_list__Finalize_merge {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_value_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_map_value_compare {
    pub _address: u8,
}
pub type std_map__Pair_alloc_type = u8;
pub type std_map__Rep_type = u8;
pub type std_map__Alloc_traits = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_deque {
    pub _address: u8,
}
pub type std_deque__Base = u8;
pub type std_deque__Tp_alloc_type = u8;
pub type std_deque__Alloc_traits = u8;
pub type std_deque__Map_pointer = u8;
pub type std_deque_value_type = u8;
pub type std_deque_pointer = u8;
pub type std_deque_const_pointer = u8;
pub type std_deque_reference = u8;
pub type std_deque_const_reference = u8;
pub type std_deque_iterator = u8;
pub type std_deque_const_iterator = u8;
pub type std_deque_const_reverse_iterator = u8;
pub type std_deque_reverse_iterator = u8;
pub type std_deque_size_type = u64;
pub type std_deque_difference_type = u64;
pub type std_deque_allocator_type = u8;
pub type std_string = [u64; 4usize];
pub type std_ostream = [u64; 34usize];
pub type std_ostringstream = [u64; 47usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_unordered_set {
    pub _address: u8,
}
pub type std_unordered_set__Hashtable = u8;
pub type std_unordered_set_key_type = u8;
pub type std_unordered_set_value_type = u8;
pub type std_unordered_set_hasher = u8;
pub type std_unordered_set_key_equal = u8;
pub type std_unordered_set_allocator_type = u8;
pub type std_unordered_set_pointer = u8;
pub type std_unordered_set_const_pointer = u8;
pub type std_unordered_set_reference = u8;
pub type std_unordered_set_const_reference = u8;
pub type std_unordered_set_iterator = u8;
pub type std_unordered_set_const_iterator = u8;
pub type std_unordered_set_local_iterator = u8;
pub type std_unordered_set_const_local_iterator = u8;
pub type std_unordered_set_size_type = u8;
pub type std_unordered_set_difference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_unordered_map {
    pub _address: u8,
}
pub type std_unordered_map__Hashtable = u8;
pub type std_unordered_map_key_type = u8;
pub type std_unordered_map_value_type = u8;
pub type std_unordered_map_mapped_type = u8;
pub type std_unordered_map_hasher = u8;
pub type std_unordered_map_key_equal = u8;
pub type std_unordered_map_allocator_type = u8;
pub type std_unordered_map_pointer = u8;
pub type std_unordered_map_const_pointer = u8;
pub type std_unordered_map_reference = u8;
pub type std_unordered_map_const_reference = u8;
pub type std_unordered_map_iterator = u8;
pub type std_unordered_map_const_iterator = u8;
pub type std_unordered_map_local_iterator = u8;
pub type std_unordered_map_const_local_iterator = u8;
pub type std_unordered_map_size_type = u8;
pub type std_unordered_map_difference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union std_vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
#[doc = " <summary>The interface event is an attachment to BWAPI interfaces which allows the user to\n register powerful conditional callbacks that can be executed a user-specified number of\n times.</summary>\n\n @tparam T\n     The interface that this class is being used for.\n\n @see Interface::registerEvent"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_InterfaceEvent {
    pub condProc: u8,
    pub execProc: u8,
    pub runFreq: ::std::os::raw::c_int,
    pub runCount: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct BWAPI_Interface__bindgen_vtable(::std::os::raw::c_void);
#[doc = " <summary>This generalized class allows the application of features that are common to all interface\n classes.</summary>\n\n @tparam T\n     The class that inherits this interface."]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_Interface {
    pub vtable_: *const BWAPI_Interface__bindgen_vtable,
    pub clientInfo: [u64; 6usize],
    pub interfaceEvents: u8,
}
pub type BWAPI_Point_list = u8;
#[doc = " <summary>Indicates a position that is 1x1 pixel in size. This is the most precise position type.</summary>\n @see Positions"]
pub type BWAPI_Position = [u32; 2usize];
#[doc = " <summary>Indicates a position that is 8x8 pixels in size.</summary>\n @see Game::isWalkable, WalkPositions"]
pub type BWAPI_WalkPosition = [u32; 2usize];
#[doc = " <summary>Indicates a position that is 32x32 pixels in size. Typically used for building placement.</summary>\n @see TilePositions"]
pub type BWAPI_TilePosition = [u32; 2usize];
#[repr(u32)]
#[doc = " <summary>Contains a list of interruptable actions that the tournament module can allow or deny.</summary>\n @see TournamentModule::onAction"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Tournament_ActionID {
    #[doc = " @see Game::enableFlag"]
    EnableFlag = 0,
    #[doc = " @see Game::pauseGame"]
    PauseGame = 1,
    #[doc = " @see Game::resumeGame"]
    ResumeGame = 2,
    #[doc = " @see Game::leaveGame"]
    LeaveGame = 3,
    #[doc = " @see Game::setLocalSpeed"]
    SetLocalSpeed = 4,
    #[doc = " @see Game::setTextSize"]
    SetTextSize = 5,
    #[doc = " @see Game::setLatCom"]
    SetLatCom = 6,
    #[doc = " @see Game::setGUI"]
    SetGUI = 7,
    #[doc = " @see Game::setMap"]
    SetMap = 8,
    #[doc = " @see Game::setFrameSkip"]
    SetFrameSkip = 9,
    #[doc = " @see Game::printf"]
    Printf = 10,
    #[doc = " @see Game::sendText"]
    SendText = 11,
    #[doc = " @see Game::setCommandOptimizationLevel"]
    SetCommandOptimizationLevel = 12,
}
pub type BWAPI_SetContainerUnderlyingT = u8;
#[doc = " <summary>This container is used to wrap convenience functions for BWAPI and be used as a\n bridge with a built-in set type.</summary>\n\n @tparam T\n     Type that this set contains.\n @tparam HashT\n     Hash type. Defaults to integral hashing for BWAPI usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_SetContainer {
    pub _address: u8,
}
#[doc = " <summary>Type that maps names to their type values.</summary>"]
pub type BWAPI_Type_typeMapT = u8;
#[doc = " <summary>A set type that contains the current type.</summary>"]
pub type BWAPI_Type_set = BWAPI_SetContainer;
#[doc = " <summary>A list type that contains the current type.</summary>"]
pub type BWAPI_Type_list = u8;
#[repr(u32)]
#[doc = " <summary>Enumeration of unit types</summary>\n @see UnitType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_UnitTypes_Enum_Enum {
    Terran_Marine = 0,
    Terran_Ghost = 1,
    Terran_Vulture = 2,
    Terran_Goliath = 3,
    Terran_Goliath_Turret = 4,
    Terran_Siege_Tank_Tank_Mode = 5,
    Terran_Siege_Tank_Tank_Mode_Turret = 6,
    Terran_SCV = 7,
    Terran_Wraith = 8,
    Terran_Science_Vessel = 9,
    Hero_Gui_Montag = 10,
    Terran_Dropship = 11,
    Terran_Battlecruiser = 12,
    Terran_Vulture_Spider_Mine = 13,
    Terran_Nuclear_Missile = 14,
    Terran_Civilian = 15,
    Hero_Sarah_Kerrigan = 16,
    Hero_Alan_Schezar = 17,
    Hero_Alan_Schezar_Turret = 18,
    Hero_Jim_Raynor_Vulture = 19,
    Hero_Jim_Raynor_Marine = 20,
    Hero_Tom_Kazansky = 21,
    Hero_Magellan = 22,
    Hero_Edmund_Duke_Tank_Mode = 23,
    Hero_Edmund_Duke_Tank_Mode_Turret = 24,
    Hero_Edmund_Duke_Siege_Mode = 25,
    Hero_Edmund_Duke_Siege_Mode_Turret = 26,
    Hero_Arcturus_Mengsk = 27,
    Hero_Hyperion = 28,
    Hero_Norad_II = 29,
    Terran_Siege_Tank_Siege_Mode = 30,
    Terran_Siege_Tank_Siege_Mode_Turret = 31,
    Terran_Firebat = 32,
    Spell_Scanner_Sweep = 33,
    Terran_Medic = 34,
    Zerg_Larva = 35,
    Zerg_Egg = 36,
    Zerg_Zergling = 37,
    Zerg_Hydralisk = 38,
    Zerg_Ultralisk = 39,
    Zerg_Broodling = 40,
    Zerg_Drone = 41,
    Zerg_Overlord = 42,
    Zerg_Mutalisk = 43,
    Zerg_Guardian = 44,
    Zerg_Queen = 45,
    Zerg_Defiler = 46,
    Zerg_Scourge = 47,
    Hero_Torrasque = 48,
    Hero_Matriarch = 49,
    Zerg_Infested_Terran = 50,
    Hero_Infested_Kerrigan = 51,
    Hero_Unclean_One = 52,
    Hero_Hunter_Killer = 53,
    Hero_Devouring_One = 54,
    Hero_Kukulza_Mutalisk = 55,
    Hero_Kukulza_Guardian = 56,
    Hero_Yggdrasill = 57,
    Terran_Valkyrie = 58,
    Zerg_Cocoon = 59,
    Protoss_Corsair = 60,
    Protoss_Dark_Templar = 61,
    Zerg_Devourer = 62,
    Protoss_Dark_Archon = 63,
    Protoss_Probe = 64,
    Protoss_Zealot = 65,
    Protoss_Dragoon = 66,
    Protoss_High_Templar = 67,
    Protoss_Archon = 68,
    Protoss_Shuttle = 69,
    Protoss_Scout = 70,
    Protoss_Arbiter = 71,
    Protoss_Carrier = 72,
    Protoss_Interceptor = 73,
    Hero_Dark_Templar = 74,
    Hero_Zeratul = 75,
    Hero_Tassadar_Zeratul_Archon = 76,
    Hero_Fenix_Zealot = 77,
    Hero_Fenix_Dragoon = 78,
    Hero_Tassadar = 79,
    Hero_Mojo = 80,
    Hero_Warbringer = 81,
    Hero_Gantrithor = 82,
    Protoss_Reaver = 83,
    Protoss_Observer = 84,
    Protoss_Scarab = 85,
    Hero_Danimoth = 86,
    Hero_Aldaris = 87,
    Hero_Artanis = 88,
    Critter_Rhynadon = 89,
    Critter_Bengalaas = 90,
    Special_Cargo_Ship = 91,
    Special_Mercenary_Gunship = 92,
    Critter_Scantid = 93,
    Critter_Kakaru = 94,
    Critter_Ragnasaur = 95,
    Critter_Ursadon = 96,
    Zerg_Lurker_Egg = 97,
    Hero_Raszagal = 98,
    Hero_Samir_Duran = 99,
    Hero_Alexei_Stukov = 100,
    Special_Map_Revealer = 101,
    Hero_Gerard_DuGalle = 102,
    Zerg_Lurker = 103,
    Hero_Infested_Duran = 104,
    Spell_Disruption_Web = 105,
    Terran_Command_Center = 106,
    Terran_Comsat_Station = 107,
    Terran_Nuclear_Silo = 108,
    Terran_Supply_Depot = 109,
    Terran_Refinery = 110,
    Terran_Barracks = 111,
    Terran_Academy = 112,
    Terran_Factory = 113,
    Terran_Starport = 114,
    Terran_Control_Tower = 115,
    Terran_Science_Facility = 116,
    Terran_Covert_Ops = 117,
    Terran_Physics_Lab = 118,
    Unused_Terran1 = 119,
    Terran_Machine_Shop = 120,
    Unused_Terran2 = 121,
    Terran_Engineering_Bay = 122,
    Terran_Armory = 123,
    Terran_Missile_Turret = 124,
    Terran_Bunker = 125,
    Special_Crashed_Norad_II = 126,
    Special_Ion_Cannon = 127,
    Powerup_Uraj_Crystal = 128,
    Powerup_Khalis_Crystal = 129,
    Zerg_Infested_Command_Center = 130,
    Zerg_Hatchery = 131,
    Zerg_Lair = 132,
    Zerg_Hive = 133,
    Zerg_Nydus_Canal = 134,
    Zerg_Hydralisk_Den = 135,
    Zerg_Defiler_Mound = 136,
    Zerg_Greater_Spire = 137,
    Zerg_Queens_Nest = 138,
    Zerg_Evolution_Chamber = 139,
    Zerg_Ultralisk_Cavern = 140,
    Zerg_Spire = 141,
    Zerg_Spawning_Pool = 142,
    Zerg_Creep_Colony = 143,
    Zerg_Spore_Colony = 144,
    Unused_Zerg1 = 145,
    Zerg_Sunken_Colony = 146,
    Special_Overmind_With_Shell = 147,
    Special_Overmind = 148,
    Zerg_Extractor = 149,
    Special_Mature_Chrysalis = 150,
    Special_Cerebrate = 151,
    Special_Cerebrate_Daggoth = 152,
    Unused_Zerg2 = 153,
    Protoss_Nexus = 154,
    Protoss_Robotics_Facility = 155,
    Protoss_Pylon = 156,
    Protoss_Assimilator = 157,
    Unused_Protoss1 = 158,
    Protoss_Observatory = 159,
    Protoss_Gateway = 160,
    Unused_Protoss2 = 161,
    Protoss_Photon_Cannon = 162,
    Protoss_Citadel_of_Adun = 163,
    Protoss_Cybernetics_Core = 164,
    Protoss_Templar_Archives = 165,
    Protoss_Forge = 166,
    Protoss_Stargate = 167,
    Special_Stasis_Cell_Prison = 168,
    Protoss_Fleet_Beacon = 169,
    Protoss_Arbiter_Tribunal = 170,
    Protoss_Robotics_Support_Bay = 171,
    Protoss_Shield_Battery = 172,
    Special_Khaydarin_Crystal_Form = 173,
    Special_Protoss_Temple = 174,
    Special_XelNaga_Temple = 175,
    Resource_Mineral_Field = 176,
    Resource_Mineral_Field_Type_2 = 177,
    Resource_Mineral_Field_Type_3 = 178,
    Unused_Cave = 179,
    Unused_Cave_In = 180,
    Unused_Cantina = 181,
    Unused_Mining_Platform = 182,
    Unused_Independant_Command_Center = 183,
    Special_Independant_Starport = 184,
    Unused_Independant_Jump_Gate = 185,
    Unused_Ruins = 186,
    Unused_Khaydarin_Crystal_Formation = 187,
    Resource_Vespene_Geyser = 188,
    Special_Warp_Gate = 189,
    Special_Psi_Disrupter = 190,
    Unused_Zerg_Marker = 191,
    Unused_Terran_Marker = 192,
    Unused_Protoss_Marker = 193,
    Special_Zerg_Beacon = 194,
    Special_Terran_Beacon = 195,
    Special_Protoss_Beacon = 196,
    Special_Zerg_Flag_Beacon = 197,
    Special_Terran_Flag_Beacon = 198,
    Special_Protoss_Flag_Beacon = 199,
    Special_Power_Generator = 200,
    Special_Overmind_Cocoon = 201,
    Spell_Dark_Swarm = 202,
    Special_Floor_Missile_Trap = 203,
    Special_Floor_Hatch = 204,
    Special_Upper_Level_Door = 205,
    Special_Right_Upper_Level_Door = 206,
    Special_Pit_Door = 207,
    Special_Right_Pit_Door = 208,
    Special_Floor_Gun_Trap = 209,
    Special_Wall_Missile_Trap = 210,
    Special_Wall_Flame_Trap = 211,
    Special_Right_Wall_Missile_Trap = 212,
    Special_Right_Wall_Flame_Trap = 213,
    Special_Start_Location = 214,
    Powerup_Flag = 215,
    Powerup_Young_Chrysalis = 216,
    Powerup_Psi_Emitter = 217,
    Powerup_Data_Disk = 218,
    Powerup_Khaydarin_Crystal = 219,
    Powerup_Mineral_Cluster_Type_1 = 220,
    Powerup_Mineral_Cluster_Type_2 = 221,
    Powerup_Protoss_Gas_Orb_Type_1 = 222,
    Powerup_Protoss_Gas_Orb_Type_2 = 223,
    Powerup_Zerg_Gas_Sac_Type_1 = 224,
    Powerup_Zerg_Gas_Sac_Type_2 = 225,
    Powerup_Terran_Gas_Tank_Type_1 = 226,
    Powerup_Terran_Gas_Tank_Type_2 = 227,
    None = 228,
    AllUnits = 229,
    Men = 230,
    Buildings = 231,
    Factories = 232,
    Unknown = 233,
    MAX = 234,
}
#[doc = " <summary>The UnitType is used to get information about a particular type of unit, such as its cost,\n build time, weapon, hit points, abilities, etc.</summary>\n\n @see UnitInterface::getType, UnitTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_UnitType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitType))
    );
}
#[doc = " <summary>UnaryFilter allows for logical functor combinations.</summary>\n\n @code\n   Unit myUnit;\n   // The following two if statements are equivalent\n   if ( myUnit->getType().isWorker() && myUnit->isCompleted() && myUnit->isIdle() )\n   {}\n\n   if ( (IsWorker && IsCompleted && IsIdle)(myUnit) )\n   {}\n @endcode\n\n @tparam PType\n   The type being passed into the predicate, which will be of type bool(PType).\n @tparam Container (optional)\n   Storage container for the function predicate. It is std::function<bool(PType)> by default."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UnaryFilter<Container> {
    pub pred: Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
}
#[doc = " <summary>The CompareFilter is a container in which a stored function predicate returns a\n value.</summary> Arithmetic and bitwise operators will return a new CompareFilter that\n applies the operation to the result of the original functor. If any relational operators are\n used, then it creates a UnaryFilter that returns the result of the operation.\n\n @tparam PType\n   The parameter type, which is the type passed into the functor.\n @tparam RType (optional)\n   The functor's return type. It is int by default.\n @tparam Container (optional)\n   Storage container for the function predicate. It is std::function<RType(PType)> by default."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_CompareFilter<Container> {
    pub pred: Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
}
#[doc = " <summary>The BestFilter is used to compare two objects with each other.</summary> Each\n function object compares two of the same object and returns the most desirable one.\n\n @note: A function object should return one of the two given parameters, never nullptr. Both\n parameters being given should never be nullptr."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_BestFilter {
    pub pred: u8,
}
#[repr(u32)]
#[doc = " <summary>Enumeration of unit size types.</summary>\n @see UnitSizeType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_UnitSizeTypes_Enum_Enum {
    Independent = 0,
    Small = 1,
    Medium = 2,
    Large = 3,
    None = 4,
    Unknown = 5,
    MAX = 6,
}
#[doc = " <summary>Size types are used by unit types in Broodwar to determine how much damage will be\n applied.</summary> This corresponds with DamageType for several different damage reduction\n applications.\n\n @see DamageType, UnitType, UnitSizeTypes\n\n [View on Starcraft Campendium (Official Website)](http://classic.battle.net/scc/gs/damage.shtml)<br>\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitSizeType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitSizeType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitSizeType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_UnitSizeType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitSizeType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitSizeType))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of upgrade types.</summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_UpgradeTypes_Enum_Enum {
    Terran_Infantry_Armor = 0,
    Terran_Vehicle_Plating = 1,
    Terran_Ship_Plating = 2,
    Zerg_Carapace = 3,
    Zerg_Flyer_Carapace = 4,
    Protoss_Ground_Armor = 5,
    Protoss_Air_Armor = 6,
    Terran_Infantry_Weapons = 7,
    Terran_Vehicle_Weapons = 8,
    Terran_Ship_Weapons = 9,
    Zerg_Melee_Attacks = 10,
    Zerg_Missile_Attacks = 11,
    Zerg_Flyer_Attacks = 12,
    Protoss_Ground_Weapons = 13,
    Protoss_Air_Weapons = 14,
    Protoss_Plasma_Shields = 15,
    U_238_Shells = 16,
    Ion_Thrusters = 17,
    Titan_Reactor = 19,
    Ocular_Implants = 20,
    Moebius_Reactor = 21,
    Apollo_Reactor = 22,
    Colossus_Reactor = 23,
    Ventral_Sacs = 24,
    Antennae = 25,
    Pneumatized_Carapace = 26,
    Metabolic_Boost = 27,
    Adrenal_Glands = 28,
    Muscular_Augments = 29,
    Grooved_Spines = 30,
    Gamete_Meiosis = 31,
    Metasynaptic_Node = 32,
    Singularity_Charge = 33,
    Leg_Enhancements = 34,
    Scarab_Damage = 35,
    Reaver_Capacity = 36,
    Gravitic_Drive = 37,
    Sensor_Array = 38,
    Gravitic_Boosters = 39,
    Khaydarin_Amulet = 40,
    Apial_Sensors = 41,
    Gravitic_Thrusters = 42,
    Carrier_Capacity = 43,
    Khaydarin_Core = 44,
    Argus_Jewel = 47,
    Argus_Talisman = 49,
    Caduceus_Reactor = 51,
    Chitinous_Plating = 52,
    Anabolic_Synthesis = 53,
    Charon_Boosters = 54,
    Upgrade_60 = 60,
    None = 61,
    Unknown = 62,
    MAX = 63,
}
#[doc = " <summary>The upgrade type represents a passive upgrade that can be obtained with\n UnitInterface::upgrade. </summary>\n\n @see UpgradeTypes\n\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UpgradeType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_UpgradeType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UpgradeType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_UpgradeType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UpgradeType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_UpgradeType))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of weapon types.</summary>\n @see WeaponType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_WeaponTypes_Enum_Enum {
    Gauss_Rifle = 0,
    Gauss_Rifle_Jim_Raynor = 1,
    C_10_Canister_Rifle = 2,
    C_10_Canister_Rifle_Sarah_Kerrigan = 3,
    Fragmentation_Grenade = 4,
    Fragmentation_Grenade_Jim_Raynor = 5,
    Spider_Mines = 6,
    Twin_Autocannons = 7,
    Hellfire_Missile_Pack = 8,
    Twin_Autocannons_Alan_Schezar = 9,
    Hellfire_Missile_Pack_Alan_Schezar = 10,
    Arclite_Cannon = 11,
    Arclite_Cannon_Edmund_Duke = 12,
    Fusion_Cutter = 13,
    Gemini_Missiles = 15,
    Burst_Lasers = 16,
    Gemini_Missiles_Tom_Kazansky = 17,
    Burst_Lasers_Tom_Kazansky = 18,
    ATS_Laser_Battery = 19,
    ATA_Laser_Battery = 20,
    ATS_Laser_Battery_Hero = 21,
    ATA_Laser_Battery_Hero = 22,
    ATS_Laser_Battery_Hyperion = 23,
    ATA_Laser_Battery_Hyperion = 24,
    Flame_Thrower = 25,
    Flame_Thrower_Gui_Montag = 26,
    Arclite_Shock_Cannon = 27,
    Arclite_Shock_Cannon_Edmund_Duke = 28,
    Longbolt_Missile = 29,
    Yamato_Gun = 30,
    Nuclear_Strike = 31,
    Lockdown = 32,
    EMP_Shockwave = 33,
    Irradiate = 34,
    Claws = 35,
    Claws_Devouring_One = 36,
    Claws_Infested_Kerrigan = 37,
    Needle_Spines = 38,
    Needle_Spines_Hunter_Killer = 39,
    Kaiser_Blades = 40,
    Kaiser_Blades_Torrasque = 41,
    Toxic_Spores = 42,
    Spines = 43,
    Acid_Spore = 46,
    Acid_Spore_Kukulza = 47,
    Glave_Wurm = 48,
    Glave_Wurm_Kukulza = 49,
    Seeker_Spores = 52,
    Subterranean_Tentacle = 53,
    Suicide_Infested_Terran = 54,
    Suicide_Scourge = 55,
    Parasite = 56,
    Spawn_Broodlings = 57,
    Ensnare = 58,
    Dark_Swarm = 59,
    Plague = 60,
    Consume = 61,
    Particle_Beam = 62,
    Psi_Blades = 64,
    Psi_Blades_Fenix = 65,
    Phase_Disruptor = 66,
    Phase_Disruptor_Fenix = 67,
    Psi_Assault = 69,
    Psionic_Shockwave = 70,
    Psionic_Shockwave_TZ_Archon = 71,
    Dual_Photon_Blasters = 73,
    Anti_Matter_Missiles = 74,
    Dual_Photon_Blasters_Mojo = 75,
    Anti_Matter_Missiles_Mojo = 76,
    Phase_Disruptor_Cannon = 77,
    Phase_Disruptor_Cannon_Danimoth = 78,
    Pulse_Cannon = 79,
    STS_Photon_Cannon = 80,
    STA_Photon_Cannon = 81,
    Scarab = 82,
    Stasis_Field = 83,
    Psionic_Storm = 84,
    Warp_Blades_Zeratul = 85,
    Warp_Blades_Hero = 86,
    Platform_Laser_Battery = 92,
    Independant_Laser_Battery = 93,
    Twin_Autocannons_Floor_Trap = 96,
    Hellfire_Missile_Pack_Wall_Trap = 97,
    Flame_Thrower_Wall_Trap = 98,
    Hellfire_Missile_Pack_Floor_Trap = 99,
    Neutron_Flare = 100,
    Disruption_Web = 101,
    Restoration = 102,
    Halo_Rockets = 103,
    Corrosive_Acid = 104,
    Mind_Control = 105,
    Feedback = 106,
    Optical_Flare = 107,
    Maelstrom = 108,
    Subterranean_Spines = 109,
    Warp_Blades = 111,
    C_10_Canister_Rifle_Samir_Duran = 112,
    C_10_Canister_Rifle_Infested_Duran = 113,
    Dual_Photon_Blasters_Artanis = 114,
    Anti_Matter_Missiles_Artanis = 115,
    C_10_Canister_Rifle_Alexei_Stukov = 116,
    None = 130,
    Unknown = 131,
    MAX = 132,
}
#[doc = " <summary>This object identifies a weapon type used by a unit to attack and deal damage.</summary>\n Some weapon types can be upgraded while others are used for special abilities.\n\n @see WeaponTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_WeaponType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_WeaponType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_WeaponType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_WeaponType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_WeaponType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_WeaponType))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of unit orders.</summary>\n @see Order"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Orders_Enum_Enum {
    Die = 0,
    Stop = 1,
    Guard = 2,
    PlayerGuard = 3,
    TurretGuard = 4,
    BunkerGuard = 5,
    Move = 6,
    ReaverStop = 7,
    Attack1 = 8,
    Attack2 = 9,
    AttackUnit = 10,
    AttackFixedRange = 11,
    AttackTile = 12,
    Hover = 13,
    AttackMove = 14,
    InfestedCommandCenter = 15,
    UnusedNothing = 16,
    UnusedPowerup = 17,
    TowerGuard = 18,
    TowerAttack = 19,
    VultureMine = 20,
    StayInRange = 21,
    TurretAttack = 22,
    Nothing = 23,
    Unused_24 = 24,
    DroneStartBuild = 25,
    DroneBuild = 26,
    CastInfestation = 27,
    MoveToInfest = 28,
    InfestingCommandCenter = 29,
    PlaceBuilding = 30,
    PlaceProtossBuilding = 31,
    CreateProtossBuilding = 32,
    ConstructingBuilding = 33,
    Repair = 34,
    MoveToRepair = 35,
    PlaceAddon = 36,
    BuildAddon = 37,
    Train = 38,
    RallyPointUnit = 39,
    RallyPointTile = 40,
    ZergBirth = 41,
    ZergUnitMorph = 42,
    ZergBuildingMorph = 43,
    IncompleteBuilding = 44,
    IncompleteMorphing = 45,
    BuildNydusExit = 46,
    EnterNydusCanal = 47,
    IncompleteWarping = 48,
    Follow = 49,
    Carrier = 50,
    ReaverCarrierMove = 51,
    CarrierStop = 52,
    CarrierAttack = 53,
    CarrierMoveToAttack = 54,
    CarrierIgnore2 = 55,
    CarrierFight = 56,
    CarrierHoldPosition = 57,
    Reaver = 58,
    ReaverAttack = 59,
    ReaverMoveToAttack = 60,
    ReaverFight = 61,
    ReaverHoldPosition = 62,
    TrainFighter = 63,
    InterceptorAttack = 64,
    ScarabAttack = 65,
    RechargeShieldsUnit = 66,
    RechargeShieldsBattery = 67,
    ShieldBattery = 68,
    InterceptorReturn = 69,
    DroneLand = 70,
    BuildingLand = 71,
    BuildingLiftOff = 72,
    DroneLiftOff = 73,
    LiftingOff = 74,
    ResearchTech = 75,
    Upgrade = 76,
    Larva = 77,
    SpawningLarva = 78,
    Harvest1 = 79,
    Harvest2 = 80,
    MoveToGas = 81,
    WaitForGas = 82,
    HarvestGas = 83,
    ReturnGas = 84,
    MoveToMinerals = 85,
    WaitForMinerals = 86,
    MiningMinerals = 87,
    Harvest3 = 88,
    Harvest4 = 89,
    ReturnMinerals = 90,
    Interrupted = 91,
    EnterTransport = 92,
    PickupIdle = 93,
    PickupTransport = 94,
    PickupBunker = 95,
    Pickup4 = 96,
    PowerupIdle = 97,
    Sieging = 98,
    Unsieging = 99,
    WatchTarget = 100,
    InitCreepGrowth = 101,
    SpreadCreep = 102,
    StoppingCreepGrowth = 103,
    GuardianAspect = 104,
    ArchonWarp = 105,
    CompletingArchonSummon = 106,
    HoldPosition = 107,
    QueenHoldPosition = 108,
    Cloak = 109,
    Decloak = 110,
    Unload = 111,
    MoveUnload = 112,
    FireYamatoGun = 113,
    MoveToFireYamatoGun = 114,
    CastLockdown = 115,
    Burrowing = 116,
    Burrowed = 117,
    Unburrowing = 118,
    CastDarkSwarm = 119,
    CastParasite = 120,
    CastSpawnBroodlings = 121,
    CastEMPShockwave = 122,
    NukeWait = 123,
    NukeTrain = 124,
    NukeLaunch = 125,
    NukePaint = 126,
    NukeUnit = 127,
    CastNuclearStrike = 128,
    NukeTrack = 129,
    InitializeArbiter = 130,
    CloakNearbyUnits = 131,
    PlaceMine = 132,
    RightClickAction = 133,
    SuicideUnit = 134,
    SuicideLocation = 135,
    SuicideHoldPosition = 136,
    CastRecall = 137,
    Teleport = 138,
    CastScannerSweep = 139,
    Scanner = 140,
    CastDefensiveMatrix = 141,
    CastPsionicStorm = 142,
    CastIrradiate = 143,
    CastPlague = 144,
    CastConsume = 145,
    CastEnsnare = 146,
    CastStasisField = 147,
    CastHallucination = 148,
    Hallucination2 = 149,
    ResetCollision = 150,
    ResetHarvestCollision = 151,
    Patrol = 152,
    CTFCOPInit = 153,
    CTFCOPStarted = 154,
    CTFCOP2 = 155,
    ComputerAI = 156,
    AtkMoveEP = 157,
    HarassMove = 158,
    AIPatrol = 159,
    GuardPost = 160,
    RescuePassive = 161,
    Neutral = 162,
    ComputerReturn = 163,
    InitializePsiProvider = 164,
    SelfDestructing = 165,
    Critter = 166,
    HiddenGun = 167,
    OpenDoor = 168,
    CloseDoor = 169,
    HideTrap = 170,
    RevealTrap = 171,
    EnableDoodad = 172,
    DisableDoodad = 173,
    WarpIn = 174,
    Medic = 175,
    MedicHeal = 176,
    HealMove = 177,
    MedicHoldPosition = 178,
    MedicHealToIdle = 179,
    CastRestoration = 180,
    CastDisruptionWeb = 181,
    CastMindControl = 182,
    DarkArchonMeld = 183,
    CastFeedback = 184,
    CastOpticalFlare = 185,
    CastMaelstrom = 186,
    JunkYardDog = 187,
    Fatal = 188,
    None = 189,
    Unknown = 190,
    MAX = 191,
}
#[doc = " <summary>An Order (Order type) represents a Unit's current action and can be retrieved with\n UnitInterface::getOrder.</summary> It can also be used to identify the current state of the\n unit during command execution (gathering minerals can consist of Orders::MoveToMinerals,\n Orders::WaitForMinerals, Orders::MiningMinerals, etc.).\n\n @see UnitInterface::getOrder, Orders\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Order {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_Order() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Order>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_Order))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Order>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_Order))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of races.</summary>\n @see Race"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Races_Enum_Enum {
    Zerg = 0,
    Terran = 1,
    Protoss = 2,
    Other = 3,
    Unused = 4,
    Select = 5,
    Random = 6,
    None = 7,
    Unknown = 8,
    MAX = 9,
}
#[doc = " <summary>The Race object is used to get information about a particular race.</summary> For\n example, the default worker and supply provider UnitType.\n\n As you should already know, Starcraft has three races: @Terran , @Protoss , and @Zerg .\n @see UnitType::getRace, PlayerInterface::getRace, Races\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Race {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_Race() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Race>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_Race))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Race>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_Race))
    );
}
pub type BWAPI_Player = *mut BWAPI_PlayerInterface;
pub type BWAPI_Unit = *mut BWAPI_UnitInterface;
#[doc = " <summary>UnaryFilter allows for logical functor combinations.</summary>\n\n @code\n   Unit myUnit;\n   // The following two if statements are equivalent\n   if ( myUnit->getType().isWorker() && myUnit->isCompleted() && myUnit->isIdle() )\n   {}\n\n   if ( (IsWorker && IsCompleted && IsIdle)(myUnit) )\n   {}\n @endcode\n\n @tparam PType\n   The type being passed into the predicate, which will be of type bool(PType).\n @tparam Container (optional)\n   Storage container for the function predicate. It is std::function<bool(PType)> by default."]
pub type BWAPI_UnitFilter = [u64; 4usize];
pub type BWAPI_PtrUnitFilter =
    BWAPI_UnaryFilter<::std::option::Option<unsafe extern "C" fn(arg1: BWAPI_Unit) -> bool>>;
pub type BWAPI_BestUnitFilter = BWAPI_BestFilter;
pub type BWAPI_PtrIntCompareUnitFilter = BWAPI_CompareFilter<
    ::std::option::Option<unsafe extern "C" fn(arg1: BWAPI_Unit) -> ::std::os::raw::c_int>,
>;
pub type BWAPI_Region = *mut BWAPI_RegionInterface;
#[doc = " <summary>The Unit class is used to get information about individual units as well as issue\n orders to units.</summary> Each unit in the game has a unique Unit object, and Unit objects\n are not deleted until the end of the match (so you don't need to worry about unit pointers\n becoming invalid).\n\n Every Unit in the game is either accessible or inaccessible. To determine if an AI can access\n a particular unit, BWAPI checks to see if Flag::CompleteMapInformation is enabled. So there\n are two cases to consider - either the flag is enabled, or it is disabled:\n\n If Flag::CompleteMapInformation is disabled, then a unit is accessible if and only if it is visible.\n @note Some properties of visible enemy units will not be made available to the AI (such as the\n contents of visible enemy dropships). If a unit is not visible, UnitInterface::exists will return false,\n regardless of whether or not the unit exists. This is because absolutely no state information on\n invisible enemy units is made available to the AI. To determine if an enemy unit has been destroyed, the\n AI must watch for AIModule::onUnitDestroy messages from BWAPI, which is only called for visible units\n which get destroyed.\n\n If Flag::CompleteMapInformation is enabled, then all units that exist in the game are accessible, and\n UnitInterface::exists is accurate for all units. Similarly AIModule::onUnitDestroy messages are generated for all\n units that get destroyed, not just visible ones.\n\n If a Unit is not accessible, then only the getInitial__ functions will be available to the AI.\n However for units that were owned by the player, getPlayer and getType will continue to work for units\n that have been destroyed.\n\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitInterface {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitInterface() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitInterface>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_UnitInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitInterface))
    );
}
#[repr(C)]
pub struct BWAPI_AIModule__bindgen_vtable(::std::os::raw::c_void);
#[doc = " <summary>AIModule is a virtual class that is intended to be implemented or inherited by a\n custom AI class.</summary> The Broodwar interface is guaranteed to be initialized if any of\n these predefined interface functions are invoked by BWAPI.\n\n @warning\n   Using BWAPI in any thread other than the thread that invokes these functions can produce\n   unexpected behaviour and possibly crash your bot. Multi-threaded AIs are possible so\n   long as all BWAPI interaction is limited to the calling thread.\n\n @note\n   Replays are considered games and call all of the same callbacks as a standard game would.\n\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_AIModule {
    pub vtable_: *const BWAPI_AIModule__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_BWAPI_AIModule() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_AIModule>(),
        8usize,
        concat!("Size of: ", stringify!(BWAPI_AIModule))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_AIModule>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_AIModule))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI8AIModuleC1Ev"]
    pub fn BWAPI_AIModule_AIModule(this: *mut BWAPI_AIModule);
}
impl BWAPI_AIModule {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_AIModule_AIModule(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI8AIModuleD1Ev"]
    pub fn BWAPI_AIModule_AIModule_destructor(this: *mut BWAPI_AIModule);
}
#[repr(C)]
pub struct BWAPI_TournamentModule__bindgen_vtable(::std::os::raw::c_void);
#[doc = " <summary>TournamentModule is a virtual class that is intended to be implemented or inherited\n by a custom Tournament class.</summary> Like AIModule, the Broodwar interface is guaranteed\n to be initialized if any of these predefined interface functions are invoked by BWAPI.\n\n @note\n   The TournamentModule is to be implemented by Tournament Modules ONLY. A standard AI module\n   should never implement it. The Tournament Module is invoked only if it is explicitly\n   defined in the configuration file. Tournament Modules also contain an AI Module interface\n   so that it can monitor the time an AI module spent during its calls using\n   Game::getLastEventTime.\n\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_TournamentModule {
    pub vtable_: *const BWAPI_TournamentModule__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_BWAPI_TournamentModule() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_TournamentModule>(),
        8usize,
        concat!("Size of: ", stringify!(BWAPI_TournamentModule))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_TournamentModule>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_TournamentModule))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI16TournamentModuleC1Ev"]
    pub fn BWAPI_TournamentModule_TournamentModule(this: *mut BWAPI_TournamentModule);
}
impl BWAPI_TournamentModule {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_TournamentModule_TournamentModule(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI16TournamentModuleD1Ev"]
    pub fn BWAPI_TournamentModule_TournamentModule_destructor(this: *mut BWAPI_TournamentModule);
}
pub type BWAPI_Bullet = *mut BWAPI_BulletInterface;
#[doc = " <summary>An interface object representing a bullet or missile spawned from an attack.</summary>\n\n The Bullet interface allows you to detect bullets, missiles, and other types\n of non-melee attacks or special abilities that would normally be visible through\n human eyes (A lurker spike or a Queen's flying parasite), allowing quicker reaction\n to unavoidable consequences.\n\n For example, ordering medics to restore units that are about to receive a lockdown\n to compensate for latency and minimize its effects. You can't know entirely which unit\n will be receiving a lockdown unless you can detect the lockdown missile using the\n Bullet class.\n\n Bullet objects are re-used after they are destroyed, however their ID is updated when it\n represents a new Bullet.\n\n If Flag::CompleteMapInformation is disabled, then a Bullet is accessible if and only if\n it is visible. Otherwise if Flag::CompleteMapInformation is enabled, then all Bullets\n in the game are accessible.\n @see Game::getBullets, BulletInterface::exists\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_BulletInterface {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_BulletInterface() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_BulletInterface>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_BulletInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_BulletInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_BulletInterface))
    );
}
#[doc = " <summary>A container for a set of Bullet objects.</summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Bulletset {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_BWAPI_Bulletset() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Bulletset>(),
        56usize,
        concat!("Size of: ", stringify!(BWAPI_Bulletset))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Bulletset>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Bulletset))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of bullet types.</summary>\n @see BulletType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_BulletTypes_Enum_Enum {
    Melee = 0,
    Fusion_Cutter_Hit = 141,
    Gauss_Rifle_Hit = 142,
    C_10_Canister_Rifle_Hit = 143,
    Gemini_Missiles = 144,
    Fragmentation_Grenade = 145,
    Longbolt_Missile = 146,
    Unused_Lockdown = 147,
    ATS_ATA_Laser_Battery = 148,
    Burst_Lasers = 149,
    Arclite_Shock_Cannon_Hit = 150,
    EMP_Missile = 151,
    Dual_Photon_Blasters_Hit = 152,
    Particle_Beam_Hit = 153,
    Anti_Matter_Missile = 154,
    Pulse_Cannon = 155,
    Psionic_Shockwave_Hit = 156,
    Psionic_Storm = 157,
    Yamato_Gun = 158,
    Phase_Disruptor = 159,
    STA_STS_Cannon_Overlay = 160,
    Sunken_Colony_Tentacle = 161,
    Venom_Unused = 162,
    Acid_Spore = 163,
    Plasma_Drip_Unused = 164,
    Glave_Wurm = 165,
    Seeker_Spores = 166,
    Queen_Spell_Carrier = 167,
    Plague_Cloud = 168,
    Consume = 169,
    Ensnare = 170,
    Needle_Spine_Hit = 171,
    Invisible = 172,
    Optical_Flare_Grenade = 201,
    Halo_Rockets = 202,
    Subterranean_Spines = 203,
    Corrosive_Acid_Shot = 204,
    Corrosive_Acid_Hit = 205,
    Neutron_Flare = 206,
    None = 209,
    Unknown = 210,
    MAX = 211,
}
#[doc = " <summary>This class represents a type of bullet. </summary>\n\n @note Internally, these are the same IDs as flingy types in Broodwar.\n\n @see BulletTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_BulletType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_BulletType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_BulletType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_BulletType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_BulletType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_BulletType))
    );
}
#[doc = " <summary>The Color object is used in drawing routines to specify the color to use.</summary>\n\n @note Starcraft uses a 256 color palette for rendering. Thus, the colors available are\n limited to this palette.\n\n @see Colors\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Color {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_Color() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Color>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Color>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_Color))
    );
}
extern "C" {
    #[doc = " <summary>A constructor that uses the color index in the palette that is closest to the\n given rgb values.</summary> On its first call, the colors in the palette will be sorted\n for fast indexing.\n\n @note This function computes the distance of the RGB values and may not be accurate.\n\n <param name=\"red\">\n   The amount of red.\n </param>\n <param name=\"green\">\n   The amount of green.\n </param>\n <param name=\"blue\">\n   The amount of blue.\n </param>"]
    #[link_name = "\u{1}_ZN5BWAPI5ColorC1Eiii"]
    pub fn BWAPI_Color_Color(
        this: *mut BWAPI_Color,
        red: ::std::os::raw::c_int,
        green: ::std::os::raw::c_int,
        blue: ::std::os::raw::c_int,
    );
}
impl BWAPI_Color {
    #[inline]
    pub unsafe fn new(
        red: ::std::os::raw::c_int,
        green: ::std::os::raw::c_int,
        blue: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_Color_Color(__bindgen_tmp.as_mut_ptr(), red, green, blue);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u32)]
#[doc = " <summary>Enumeration of text formatting codes</summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Text_Enum {
    #[doc = " <summary>Uses the previous color that was specified before the current one.</summary>"]
    Previous = 1,
    #[doc = " <summary>Uses the default blueish color. This color is used in standard game messages.</summary>"]
    Default = 2,
    #[doc = " <summary>A solid yellow. This yellow is used in notifications and is also the default\n color when printing text to Broodwar.</summary>"]
    Yellow = 3,
    #[doc = " <summary>A bright white. This is used for timers.</summary>"]
    White = 4,
    #[doc = " <summary>A dark grey. This color code will override all color formatting that follows.</summary>"]
    Grey = 5,
    #[doc = " <summary>A deep red. This color code is used for error messages.</summary>"]
    Red = 6,
    #[doc = " <summary>A solid green. This color is used for sent messages and resource counters.</summary>"]
    Green = 7,
    #[doc = " <summary>A type of red. This color is used to color the name of the red player.</summary>"]
    BrightRed = 8,
    #[doc = " <summary>This code hides all text and formatting that follows.</summary>"]
    Invisible = 11,
    #[doc = " <summary>A deep blue. This color is used to color the name of the blue player.</summary>"]
    Blue = 14,
    #[doc = " <summary>A teal color. This color is used to color the name of the teal player.</summary>"]
    Teal = 15,
    #[doc = " <summary>A deep purple. This color is used to color the name of the purple player.</summary>"]
    Purple = 16,
    #[doc = " <summary>A solid orange. This color is used to color the name of the orange player.</summary>"]
    Orange = 17,
    #[doc = " <summary>An alignment directive that aligns the text to the right side of the screen.</summary>"]
    Align_Right = 18,
    #[doc = " <summary>An alignment directive that aligns the text to the center of the screen.</summary>"]
    Align_Center = 19,
    #[doc = " @copydoc Invisible"]
    Invisible2 = 20,
    #[doc = " <summary>A dark brown. This color is used to color the name of the brown player.</summary>"]
    Brown = 21,
    #[doc = " <summary>A dirty white. This color is used to color the name of the white player.</summary>"]
    PlayerWhite = 22,
    #[doc = " <summary>A deep yellow. This color is used to color the name of the yellow player.</summary>"]
    PlayerYellow = 23,
    #[doc = " <summary>A dark green. This color is used to color the name of the green player.</summary>"]
    DarkGreen = 24,
    #[doc = " <summary>A bright yellow.</summary>"]
    LightYellow = 25,
    #[doc = " <summary>A cyan color. Similar to Default.</summary>"]
    Cyan = 26,
    #[doc = " <summary>A tan color.</summary>"]
    Tan = 27,
    #[doc = " <summary>A dark blueish color.</summary>"]
    GreyBlue = 28,
    #[doc = " <summary>A type of Green.</summary>"]
    GreyGreen = 29,
    #[doc = " <summary>A different type of Cyan.</summary>"]
    GreyCyan = 30,
    #[doc = " <summary>A bright blue color.</summary>"]
    Turquoise = 31,
}
#[repr(u32)]
#[doc = " <summary>Enumeration of available text sizes</summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Text_Size_Enum {
    #[doc = " <summary>The smallest text size in the game.</summary>"]
    Small = 0,
    #[doc = " <summary>The standard text size, used for most things in the game such as chat messages.</summary>"]
    Default = 1,
    #[doc = " <summary>A larger text size. This size is used for the in-game countdown timer seen in @CTF and @UMS game types.</summary>"]
    Large = 2,
    #[doc = " <summary>The largest text size in the game.</summary>"]
    Huge = 3,
}
#[repr(u32)]
#[doc = " <summary>The coordinate type enumeration, used to indicate relative drawing positions.</summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_CoordinateType_Enum {
    #[doc = " <summary>A default value for uninitialized coordinate types.</summary>"]
    None = 0,
    #[doc = " <summary>Positions::Origin (0,0) corresponds to the top left corner of the <b>screen</b>.</summary>"]
    Screen = 1,
    #[doc = " <summary>Positions::Origin (0,0) corresponds to the top left corner of the <b>map</b>.</summary>"]
    Map = 2,
    #[doc = " <summary>Positions::Origin (0,0) corresponds to the location of the <b>mouse cursor</b>.</summary>"]
    Mouse = 3,
}
#[repr(u32)]
#[doc = " <summary>Enumeration of damage types.</summary>\n @see DamageType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_DamageTypes_Enum_Enum {
    Independent = 0,
    Explosive = 1,
    Concussive = 2,
    Normal = 3,
    Ignore_Armor = 4,
    None = 5,
    Unknown = 6,
    MAX = 7,
}
#[doc = " <summary>Damage types are used in Broodwar to determine the amount of damage that will be\n done to a unit.</summary> This corresponds with UnitSizeType to determine the damage done to\n a unit.\n\n @see WeaponType, DamageTypes, UnitSizeType\n\n [View on Liquipedia](http://wiki.teamliquid.net/starcraft/Damage_Type)<br>\n [View on Starcraft Campendium (Official Website)](http://classic.battle.net/scc/gs/damage.shtml)<br>\n [View on Starcraft Wikia](http://starcraft.wikia.com/wiki/Damage_types)<br>\n\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_DamageType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_DamageType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_DamageType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_DamageType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_DamageType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_DamageType))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of Error types.</summary>\n @see Error"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Errors_Enum_Enum {
    Unit_Does_Not_Exist = 0,
    Unit_Not_Visible = 1,
    Unit_Not_Owned = 2,
    Unit_Busy = 3,
    Incompatible_UnitType = 4,
    Incompatible_TechType = 5,
    Incompatible_State = 6,
    Already_Researched = 7,
    Fully_Upgraded = 8,
    Currently_Researching = 9,
    Currently_Upgrading = 10,
    Insufficient_Minerals = 11,
    Insufficient_Gas = 12,
    Insufficient_Supply = 13,
    Insufficient_Energy = 14,
    Insufficient_Tech = 15,
    Insufficient_Ammo = 16,
    Insufficient_Space = 17,
    Invalid_Tile_Position = 18,
    Unbuildable_Location = 19,
    Unreachable_Location = 20,
    Out_Of_Range = 21,
    Unable_To_Hit = 22,
    Access_Denied = 23,
    File_Not_Found = 24,
    Invalid_Parameter = 25,
    None = 26,
    Unknown = 27,
    MAX = 28,
}
#[doc = " <summary>The Error object is generally used to determine why certain functions in BWAPI\n have failed.</summary>\n\n For example, you may not have enough resources to construct a unit.\n @see Game::getLastError, Game::setLastError, Errors\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Error {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_Error() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Error>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_Error))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Error>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_Error))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of callback event types.</summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_EventType_Enum {
    MatchStart = 0,
    MatchEnd = 1,
    MatchFrame = 2,
    MenuFrame = 3,
    SendText = 4,
    ReceiveText = 5,
    PlayerLeft = 6,
    NukeDetect = 7,
    UnitDiscover = 8,
    UnitEvade = 9,
    UnitShow = 10,
    UnitHide = 11,
    UnitCreate = 12,
    UnitDestroy = 13,
    UnitMorph = 14,
    UnitRenegade = 15,
    SaveGame = 16,
    UnitComplete = 17,
    None = 18,
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_Event {
    pub position: BWAPI_Position,
    pub text: *mut std_string,
    pub unit: BWAPI_Unit,
    pub player: BWAPI_Player,
    pub type_: BWAPI_EventType_Enum,
    pub winner: bool,
}
#[test]
fn bindgen_test_layout_BWAPI_Event() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Event>(),
        40usize,
        concat!("Size of: ", stringify!(BWAPI_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).player) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(player)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).winner) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Event),
            "::",
            stringify!(winner)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI5EventC1ERKS0_"]
    pub fn BWAPI_Event_Event(this: *mut BWAPI_Event, other: *const BWAPI_Event);
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI5EventC1EOS0_"]
    pub fn BWAPI_Event_Event1(this: *mut BWAPI_Event, other: *mut BWAPI_Event);
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI5EventD1Ev"]
    pub fn BWAPI_Event_Event_destructor(this: *mut BWAPI_Event);
}
impl BWAPI_Event {
    #[inline]
    pub unsafe fn new(other: *const BWAPI_Event) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_Event_Event(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *mut BWAPI_Event) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_Event_Event1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        BWAPI_Event_Event_destructor(self)
    }
}
#[repr(u32)]
#[doc = " <summary>Enumeration of explosion types.</summary>\n @see ExplosionType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_ExplosionTypes_Enum_Enum {
    None = 0,
    Normal = 1,
    Radial_Splash = 2,
    Enemy_Splash = 3,
    Lockdown = 4,
    Nuclear_Missile = 5,
    Parasite = 6,
    Broodlings = 7,
    EMP_Shockwave = 8,
    Irradiate = 9,
    Ensnare = 10,
    Plague = 11,
    Stasis_Field = 12,
    Dark_Swarm = 13,
    Consume = 14,
    Yamato_Gun = 15,
    Restoration = 16,
    Disruption_Web = 17,
    Corrosive_Acid = 18,
    Mind_Control = 19,
    Feedback = 20,
    Optical_Flare = 21,
    Maelstrom = 22,
    Unused = 23,
    Air_Splash = 24,
    Unknown = 25,
    MAX = 26,
}
#[doc = " <summary>A representation of a weapon's explosion type.</summary> This indicates how the\n weapon behaves, such as if it deals splash damage or causes an effect to occur.\n\n @see ExplosionTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_ExplosionType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_ExplosionType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_ExplosionType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_ExplosionType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_ExplosionType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_ExplosionType))
    );
}
#[repr(u32)]
#[doc = " <summary>Contains flag enumerations for BWAPI.</summary>\n @see Game::enableFlag, Game::isFlagEnabled"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Flag_Enum {
    #[doc = " <summary>Enable to get information about all units on the map, not just the visible units.</summary>"]
    CompleteMapInformation = 0,
    #[doc = " <summary>Enable to get information from the user (what units are selected, chat messages\n the user enters, etc)</summary>"]
    UserInput = 1,
    #[doc = " <summary>The maximum number of different flags available.</summary>"]
    Max = 2,
}
pub type BWAPI_Force = *mut BWAPI_ForceInterface;
#[doc = " <summary>The Force class is used to get information about each force in a match.</summary>\n Normally this is considered a team.\n\n @note It is not called a team because players on the same force do not necessarily need\n to be allied at the beginning of a match.\n\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_ForceInterface {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_ForceInterface() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_ForceInterface>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_ForceInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_ForceInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_ForceInterface))
    );
}
#[doc = " <summary>A container that holds a group of Forces.</summary>\n\n @see BWAPI::Force"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Forceset {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_BWAPI_Forceset() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Forceset>(),
        56usize,
        concat!("Size of: ", stringify!(BWAPI_Forceset))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Forceset>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Forceset))
    );
}
#[repr(u32)]
#[doc = " <summary>An enumeration of mouse button inputs.</summary>\n @see Game::getMouseState"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_MouseButton {
    M_LEFT = 0,
    M_RIGHT = 1,
    M_MIDDLE = 2,
    M_MAX = 3,
}
#[repr(u32)]
#[doc = " <summary>An enumeration of keyboard input values.</summary>\n @see Game::getKeyState"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Key {
    K_LBUTTON = 1,
    K_RBUTTON = 2,
    K_CANCEL = 3,
    K_MBUTTON = 4,
    K_XBUTTON1 = 5,
    K_XBUTTON2 = 6,
    __UNDEFINED_7 = 7,
    K_BACK = 8,
    K_TAB = 9,
    __RESERVED_A = 10,
    __RESERVED_B = 11,
    K_CLEAR = 12,
    K_RETURN = 13,
    __UNDEFINED_E = 14,
    __UNDEFINED_F = 15,
    K_SHIFT = 16,
    K_CONTROL = 17,
    K_MENU = 18,
    K_PAUSE = 19,
    K_CAPITAL = 20,
    K_KANA = 21,
    K_UNDEFINED_16 = 22,
    K_JUNJA = 23,
    K_FINAL = 24,
    K_KANJI = 25,
    __UNDEFINED_1A = 26,
    K_ESCAPE = 27,
    K_CONVERT = 28,
    K_NONCONVERT = 29,
    K_ACCEPT = 30,
    K_MODECHANGE = 31,
    K_SPACE = 32,
    K_PRIOR = 33,
    K_NEXT = 34,
    K_END = 35,
    K_HOME = 36,
    K_LEFT = 37,
    K_UP = 38,
    K_RIGHT = 39,
    K_DOWN = 40,
    K_SELECT = 41,
    K_PRINT = 42,
    K_EXECUTE = 43,
    K_SNAPSHOT = 44,
    K_INSERT = 45,
    K_DELETE = 46,
    K_HELP = 47,
    K_0 = 48,
    K_1 = 49,
    K_2 = 50,
    K_3 = 51,
    K_4 = 52,
    K_5 = 53,
    K_6 = 54,
    K_7 = 55,
    K_8 = 56,
    K_9 = 57,
    __UNDEFINED_3A = 58,
    __UNDEFINED_3B = 59,
    __UNDEFINED_3C = 60,
    __UNDEFINED_3D = 61,
    __UNDEFINED_3E = 62,
    __UNDEFINED_3F = 63,
    __UNDEFINED_40 = 64,
    K_A = 65,
    K_B = 66,
    K_C = 67,
    K_D = 68,
    K_E = 69,
    K_F = 70,
    K_G = 71,
    K_H = 72,
    K_I = 73,
    K_J = 74,
    K_K = 75,
    K_L = 76,
    K_M = 77,
    K_N = 78,
    K_O = 79,
    K_P = 80,
    K_Q = 81,
    K_R = 82,
    K_S = 83,
    K_T = 84,
    K_U = 85,
    K_V = 86,
    K_W = 87,
    K_X = 88,
    K_Y = 89,
    K_Z = 90,
    K_LWIN = 91,
    K_RWIN = 92,
    K_APPS = 93,
    __RESERVED_5E = 94,
    K_SLEEP = 95,
    K_NUMPAD0 = 96,
    K_NUMPAD1 = 97,
    K_NUMPAD2 = 98,
    K_NUMPAD3 = 99,
    K_NUMPAD4 = 100,
    K_NUMPAD5 = 101,
    K_NUMPAD6 = 102,
    K_NUMPAD7 = 103,
    K_NUMPAD8 = 104,
    K_NUMPAD9 = 105,
    K_MULTIPLY = 106,
    K_ADD = 107,
    K_SEPARATOR = 108,
    K_SUBTRACT = 109,
    K_DECIMAL = 110,
    K_DIVIDE = 111,
    K_F1 = 112,
    K_F2 = 113,
    K_F3 = 114,
    K_F4 = 115,
    K_F5 = 116,
    K_F6 = 117,
    K_F7 = 118,
    K_F8 = 119,
    K_F9 = 120,
    K_F10 = 121,
    K_F11 = 122,
    K_F12 = 123,
    K_F13 = 124,
    K_F14 = 125,
    K_F15 = 126,
    K_F16 = 127,
    K_F17 = 128,
    K_F18 = 129,
    K_F19 = 130,
    K_F20 = 131,
    K_F21 = 132,
    K_F22 = 133,
    K_F23 = 134,
    K_F24 = 135,
    __UNASSIGNED_88 = 136,
    __UNASSIGNED_89 = 137,
    __UNASSIGNED_8A = 138,
    __UNASSIGNED_8B = 139,
    __UNASSIGNED_8C = 140,
    __UNASSIGNED_8D = 141,
    __UNASSIGNED_8E = 142,
    __UNASSIGNED_8F = 143,
    K_NUMLOCK = 144,
    K_SCROLL = 145,
    K_OEM_NEC_EQUAL = 146,
    K_OEM_FJ_JISHO = 147,
    K_OEM_FJ_MASSHOU = 148,
    K_OEM_FJ_TOUROKU = 149,
    K_OEM_FJ_LOYA = 150,
    __UNASSIGNED_97 = 151,
    __UNASSIGNED_98 = 152,
    __UNASSIGNED_99 = 153,
    __UNASSIGNED_9A = 154,
    __UNASSIGNED_9B = 155,
    __UNASSIGNED_9C = 156,
    __UNASSIGNED_9D = 157,
    __UNASSIGNED_9E = 158,
    __UNASSIGNED_9F = 159,
    K_LSHIFT = 160,
    K_RSHIFT = 161,
    K_LCONTROL = 162,
    K_RCONTROL = 163,
    K_LMENU = 164,
    K_RMENU = 165,
    K_BROWSER_BACK = 166,
    K_BROWSER_FORWARD = 167,
    K_BROWSER_REFRESH = 168,
    K_BROWSER_STOP = 169,
    K_BROWSER_SEARCH = 170,
    K_BROWSER_FAVORITES = 171,
    K_BROWSER_HOME = 172,
    K_VOLUME_MUTE = 173,
    K_VOLUME_DOWN = 174,
    K_VOLUME_UP = 175,
    K_MEDIA_NEXT_TRACK = 176,
    K_MEDIA_PREV_TRACK = 177,
    K_MEDIA_STOP = 178,
    K_MEDIA_PLAY_PAUSE = 179,
    K_LAUNCH_MAIL = 180,
    K_LAUNCH_MEDIA_SELECT = 181,
    K_LAUNCH_APP1 = 182,
    K_LAUNCH_APP2 = 183,
    __RESERVED_B8 = 184,
    __RESERVED_B9 = 185,
    K_OEM_1 = 186,
    K_OEM_PLUS = 187,
    K_OEM_COMMA = 188,
    K_OEM_MINUS = 189,
    K_OEM_PERIOD = 190,
    K_OEM_2 = 191,
    K_OEM_3 = 192,
    K_OEM_4 = 219,
    K_OEM_5 = 220,
    K_OEM_6 = 221,
    K_OEM_7 = 222,
    K_OEM_8 = 223,
    __RESERVED_E0 = 224,
    K_OEM_AX = 225,
    K_OEM_102 = 226,
    K_ICO_HELP = 227,
    K_ICO_00 = 228,
    K_PROCESSKEY = 229,
    K_ICO_CLEAR = 230,
    K_PACKET = 231,
    __UNASSIGNED_E8 = 232,
    K_OEM_RESET = 233,
    K_OEM_JUMP = 234,
    K_OEM_PA1 = 235,
    K_OEM_PA2 = 236,
    K_OEM_PA3 = 237,
    K_OEM_WSCTRL = 238,
    K_OEM_CUSEL = 239,
    K_OEM_ATTN = 240,
    K_OEM_FINISH = 241,
    K_OEM_COPY = 242,
    K_OEM_AUTO = 243,
    K_OEM_ENLW = 244,
    K_OEM_BACKTAB = 245,
    K_ATTN = 246,
    K_CRSEL = 247,
    K_EXSEL = 248,
    K_EREOF = 249,
    K_PLAY = 250,
    K_ZOOM = 251,
    K_NONAME = 252,
    K_PA1 = 253,
    K_OEM_CLEAR = 254,
    K_MAX = 255,
}
#[doc = " <summary>The abstract Game class is implemented by BWAPI and is the primary means of obtaining all\n game state information from Starcraft Broodwar.</summary> Game state information includes all units,\n resources, players, forces, bullets, terrain, fog of war, regions, etc.\n\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_Game {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_Game() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Game>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_Game))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Game>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Game))
    );
}
#[doc = " <summary>Broodwar wrapper"]
#[repr(C)]
pub struct BWAPI_GameWrapper {
    pub ss: std_ostringstream,
}
#[doc = " <summary>Definition of ostream_manipulator type for convenience.</summary>"]
pub type BWAPI_GameWrapper_ostream_manipulator =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut std_ostream) -> *mut std_ostream>;
#[test]
fn bindgen_test_layout_BWAPI_GameWrapper() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_GameWrapper> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameWrapper>(),
        376usize,
        concat!("Size of: ", stringify!(BWAPI_GameWrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_GameWrapper))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameWrapper),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of game types.</summary>\n @see GameType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_GameTypes_Enum_Enum {
    None = 0,
    Custom = 1,
    Melee = 2,
    Free_For_All = 3,
    One_on_One = 4,
    Capture_The_Flag = 5,
    Greed = 6,
    Slaughter = 7,
    Sudden_Death = 8,
    Ladder = 9,
    Use_Map_Settings = 10,
    Team_Melee = 11,
    Team_Free_For_All = 12,
    Team_Capture_The_Flag = 13,
    Unknown_0x0E = 14,
    Top_vs_Bottom = 15,
    Iron_Man_Ladder = 16,
    Pro_Gamer_League = 32,
    Unknown = 33,
    MAX = 34,
}
#[doc = " <summary>A class that represents game types in Broodwar.</summary> A game type is selected\n when creating a game.\n\n @see GameTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_GameType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_GameType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_GameType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_GameType))
    );
}
#[repr(u32)]
#[doc = " <summary>Contains enumeration of known latency values.</summary>\n @see Game::getLatency"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_Latency_Enum {
    SinglePlayer = 2,
    LanLow = 5,
    LanMedium = 7,
    LanHigh = 9,
    BattlenetLow = 14,
    BattlenetMedium = 19,
    BattlenetHigh = 24,
}
#[doc = " <summary>The Player represents a unique controller in the game.</summary> Each player in\n a match will have his or her own player instance. There is also a neutral player which owns\n all the neutral units (such as mineral patches and vespene geysers).\n\n @see Playerset, PlayerType, Race\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_PlayerInterface {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_PlayerInterface() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_PlayerInterface>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_PlayerInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_PlayerInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_PlayerInterface))
    );
}
#[doc = " <summary>A set containing Player objects.</summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Playerset {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_BWAPI_Playerset() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Playerset>(),
        56usize,
        concat!("Size of: ", stringify!(BWAPI_Playerset))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Playerset>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Playerset))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of player types (player controllers).</summary>\n @see PlayerType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_PlayerTypes_Enum_Enum {
    None = 0,
    Computer = 1,
    Player = 2,
    RescuePassive = 3,
    RescueActive = 4,
    EitherPreferComputer = 5,
    EitherPreferHuman = 6,
    Neutral = 7,
    Closed = 8,
    Observer = 9,
    PlayerLeft = 10,
    ComputerLeft = 11,
    Unknown = 12,
    MAX = 13,
}
#[doc = " <summary>Represents the type of controller for the player slot (i.e. human, computer).</summary>\n\n @see PlayerTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_PlayerType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_PlayerType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_PlayerType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_PlayerType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_PlayerType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_PlayerType))
    );
}
#[doc = " <summary>Region objects are created by Starcraft: Broodwar to contain several tiles with the same\n properties, and create a node in pathfinding and other algorithms.</summary> Regions may not contain\n detailed information, but have a sufficient amount of data to identify general chokepoints,\n accessibility to neighboring terrain, be used in general pathing algorithms, and used as\n nodes to rally units to.\n\n Most parameters that are available are explicitly assigned by Broodwar itself.\n\n @see Game::getAllRegions, Game::getRegionAt, UnitInterface::getRegion\n @ingroup Interface"]
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_RegionInterface {
    pub _base: BWAPI_Interface,
}
#[test]
fn bindgen_test_layout_BWAPI_RegionInterface() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_RegionInterface>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_RegionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_RegionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_RegionInterface))
    );
}
#[doc = " <summary>A container that holds a set of Region objects.</summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Regionset {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_BWAPI_Regionset() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Regionset>(),
        56usize,
        concat!("Size of: ", stringify!(BWAPI_Regionset))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Regionset>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Regionset))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of Tech Types.</summary>\n @see TechType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_TechTypes_Enum_Enum {
    Stim_Packs = 0,
    Lockdown = 1,
    EMP_Shockwave = 2,
    Spider_Mines = 3,
    Scanner_Sweep = 4,
    Tank_Siege_Mode = 5,
    Defensive_Matrix = 6,
    Irradiate = 7,
    Yamato_Gun = 8,
    Cloaking_Field = 9,
    Personnel_Cloaking = 10,
    Burrowing = 11,
    Infestation = 12,
    Spawn_Broodlings = 13,
    Dark_Swarm = 14,
    Plague = 15,
    Consume = 16,
    Ensnare = 17,
    Parasite = 18,
    Psionic_Storm = 19,
    Hallucination = 20,
    Recall = 21,
    Stasis_Field = 22,
    Archon_Warp = 23,
    Restoration = 24,
    Disruption_Web = 25,
    Unused_26 = 26,
    Mind_Control = 27,
    Dark_Archon_Meld = 28,
    Feedback = 29,
    Optical_Flare = 30,
    Maelstrom = 31,
    Lurker_Aspect = 32,
    Unused_33 = 33,
    Healing = 34,
    None = 44,
    Nuclear_Strike = 45,
    Unknown = 46,
    MAX = 47,
}
#[doc = " <summary>The TechType (or Technology Type, also referred to as an Ability) represents a Unit's ability\n which can be researched with UnitInterface::research or used with UnitInterface::useTech.</summary>\n In order for a Unit to use its own specialized ability, it must first be available and researched.\n\n @see TechTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_TechType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_TechType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_TechType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_TechType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_TechType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_TechType))
    );
}
#[repr(u32)]
#[doc = " <summary>Enumeration of valid unit command types.</summary>\n @see UnitCommandType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPI_UnitCommandTypes_Enum_Enum {
    Attack_Move = 0,
    Attack_Unit = 1,
    Build = 2,
    Build_Addon = 3,
    Train = 4,
    Morph = 5,
    Research = 6,
    Upgrade = 7,
    Set_Rally_Position = 8,
    Set_Rally_Unit = 9,
    Move = 10,
    Patrol = 11,
    Hold_Position = 12,
    Stop = 13,
    Follow = 14,
    Gather = 15,
    Return_Cargo = 16,
    Repair = 17,
    Burrow = 18,
    Unburrow = 19,
    Cloak = 20,
    Decloak = 21,
    Siege = 22,
    Unsiege = 23,
    Lift = 24,
    Land = 25,
    Load = 26,
    Unload = 27,
    Unload_All = 28,
    Unload_All_Position = 29,
    Right_Click_Position = 30,
    Right_Click_Unit = 31,
    Halt_Construction = 32,
    Cancel_Construction = 33,
    Cancel_Addon = 34,
    Cancel_Train = 35,
    Cancel_Train_Slot = 36,
    Cancel_Morph = 37,
    Cancel_Research = 38,
    Cancel_Upgrade = 39,
    Use_Tech = 40,
    Use_Tech_Position = 41,
    Use_Tech_Unit = 42,
    Place_COP = 43,
    None = 44,
    Unknown = 45,
    MAX = 46,
}
#[doc = " <summary>A representation of a unit command in BWAPI.</summary> This is used by bots to\n notify BWAPI which commands to use. BWAPI filters commands accordingly and then converts\n them to Broodwar commands, which differ in complexity.\n\n @see UnitCommandTypes\n @ingroup TypeClasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitCommandType {
    pub _base: u32,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitCommandType() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitCommandType>(),
        4usize,
        concat!("Size of: ", stringify!(BWAPI_UnitCommandType))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitCommandType>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitCommandType))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitCommand {
    pub unit: BWAPI_Unit,
    pub type_: BWAPI_UnitCommandType,
    pub target: BWAPI_Unit,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub extra: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitCommand() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_UnitCommand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitCommand>(),
        40usize,
        concat!("Size of: ", stringify!(BWAPI_UnitCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitCommand>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitCommand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitCommand),
            "::",
            stringify!(extra)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI11UnitCommandC1EPNS_13UnitInterfaceENS_15UnitCommandTypeES2_iii"]
    pub fn BWAPI_UnitCommand_UnitCommand(
        this: *mut BWAPI_UnitCommand,
        _unit: BWAPI_Unit,
        _type: BWAPI_UnitCommandType,
        _target: BWAPI_Unit,
        _x: ::std::os::raw::c_int,
        _y: ::std::os::raw::c_int,
        _extra: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI11UnitCommandC1EPNS_13UnitInterfaceENS_15UnitCommandTypeE"]
    pub fn BWAPI_UnitCommand_UnitCommand1(
        this: *mut BWAPI_UnitCommand,
        _unit: BWAPI_Unit,
        _type: BWAPI_UnitCommandType,
    );
}
impl BWAPI_UnitCommand {
    #[inline]
    pub unsafe fn new(
        _unit: BWAPI_Unit,
        _type: BWAPI_UnitCommandType,
        _target: BWAPI_Unit,
        _x: ::std::os::raw::c_int,
        _y: ::std::os::raw::c_int,
        _extra: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_UnitCommand_UnitCommand(
            __bindgen_tmp.as_mut_ptr(),
            _unit,
            _type,
            _target,
            _x,
            _y,
            _extra,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(_unit: BWAPI_Unit, _type: BWAPI_UnitCommandType) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_UnitCommand_UnitCommand1(__bindgen_tmp.as_mut_ptr(), _unit, _type);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " <summary>The Unitset is a container for a set of pointers to Unit objects. It is typically\n used for groups of units instead of having to manage each Unit individually.</summary>\n\n @see Unit"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_Unitset {
    pub _address: u8,
}
extern "C" {
    #[doc = " <summary>A blank Unitset containing no elements.</summary> This is typically used as a\n return value for BWAPI interface functions that have encountered an error."]
    #[link_name = "\u{1}_ZN5BWAPI7Unitset4noneE"]
    pub static BWAPI_Unitset_none: BWAPI_Unitset;
}
#[test]
fn bindgen_test_layout_BWAPI_Unitset() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Unitset>(),
        56usize,
        concat!("Size of: ", stringify!(BWAPI_Unitset))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Unitset>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Unitset))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_ForceData {
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_BWAPI_ForceData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_ForceData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_ForceData>(),
        32usize,
        concat!("Size of: ", stringify!(BWAPI_ForceData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_ForceData>(),
        1usize,
        concat!("Alignment of ", stringify!(BWAPI_ForceData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_ForceData),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_PlayerData {
    pub name: [::std::os::raw::c_char; 25usize],
    pub race: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub force: ::std::os::raw::c_int,
    pub isAlly: [bool; 12usize],
    pub isEnemy: [bool; 12usize],
    pub isNeutral: bool,
    pub startLocationX: ::std::os::raw::c_int,
    pub startLocationY: ::std::os::raw::c_int,
    pub isVictorious: bool,
    pub isDefeated: bool,
    pub leftGame: bool,
    pub isParticipating: bool,
    pub minerals: ::std::os::raw::c_int,
    pub gas: ::std::os::raw::c_int,
    pub gatheredMinerals: ::std::os::raw::c_int,
    pub gatheredGas: ::std::os::raw::c_int,
    pub repairedMinerals: ::std::os::raw::c_int,
    pub repairedGas: ::std::os::raw::c_int,
    pub refundedMinerals: ::std::os::raw::c_int,
    pub refundedGas: ::std::os::raw::c_int,
    pub supplyTotal: [::std::os::raw::c_int; 3usize],
    pub supplyUsed: [::std::os::raw::c_int; 3usize],
    pub allUnitCount: [::std::os::raw::c_int; 234usize],
    pub visibleUnitCount: [::std::os::raw::c_int; 234usize],
    pub completedUnitCount: [::std::os::raw::c_int; 234usize],
    pub deadUnitCount: [::std::os::raw::c_int; 234usize],
    pub killedUnitCount: [::std::os::raw::c_int; 234usize],
    pub upgradeLevel: [::std::os::raw::c_int; 63usize],
    pub hasResearched: [bool; 47usize],
    pub isResearching: [bool; 47usize],
    pub isUpgrading: [bool; 63usize],
    pub color: ::std::os::raw::c_int,
    pub totalUnitScore: ::std::os::raw::c_int,
    pub totalKillScore: ::std::os::raw::c_int,
    pub totalBuildingScore: ::std::os::raw::c_int,
    pub totalRazingScore: ::std::os::raw::c_int,
    pub customScore: ::std::os::raw::c_int,
    pub maxUpgradeLevel: [::std::os::raw::c_int; 63usize],
    pub isResearchAvailable: [bool; 47usize],
    pub isUnitAvailable: [bool; 234usize],
}
#[test]
fn bindgen_test_layout_BWAPI_PlayerData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_PlayerData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_PlayerData>(),
        5788usize,
        concat!("Size of: ", stringify!(BWAPI_PlayerData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_PlayerData>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_PlayerData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).race) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(race)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(force)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isAlly) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isAlly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isEnemy) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isEnemy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isNeutral) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isNeutral)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startLocationX) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(startLocationX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startLocationY) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(startLocationY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isVictorious) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isVictorious)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDefeated) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isDefeated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftGame) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(leftGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isParticipating) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isParticipating)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minerals) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(minerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(gas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gatheredMinerals) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(gatheredMinerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gatheredGas) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(gatheredGas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repairedMinerals) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(repairedMinerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repairedGas) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(repairedGas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refundedMinerals) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(refundedMinerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refundedGas) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(refundedGas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supplyTotal) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(supplyTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supplyUsed) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(supplyUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allUnitCount) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(allUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visibleUnitCount) as usize - ptr as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(visibleUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completedUnitCount) as usize - ptr as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(completedUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadUnitCount) as usize - ptr as usize },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(deadUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).killedUnitCount) as usize - ptr as usize },
        3880usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(killedUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upgradeLevel) as usize - ptr as usize },
        4816usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(upgradeLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasResearched) as usize - ptr as usize },
        5068usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(hasResearched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isResearching) as usize - ptr as usize },
        5115usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isResearching)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isUpgrading) as usize - ptr as usize },
        5162usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isUpgrading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        5228usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalUnitScore) as usize - ptr as usize },
        5232usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(totalUnitScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalKillScore) as usize - ptr as usize },
        5236usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(totalKillScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalBuildingScore) as usize - ptr as usize },
        5240usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(totalBuildingScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalRazingScore) as usize - ptr as usize },
        5244usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(totalRazingScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customScore) as usize - ptr as usize },
        5248usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(customScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxUpgradeLevel) as usize - ptr as usize },
        5252usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(maxUpgradeLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isResearchAvailable) as usize - ptr as usize },
        5504usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isResearchAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isUnitAvailable) as usize - ptr as usize },
        5551usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerData),
            "::",
            stringify!(isUnitAvailable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_RegionData {
    pub id: ::std::os::raw::c_int,
    pub islandID: ::std::os::raw::c_int,
    pub center_x: ::std::os::raw::c_int,
    pub center_y: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
    pub leftMost: ::std::os::raw::c_int,
    pub rightMost: ::std::os::raw::c_int,
    pub topMost: ::std::os::raw::c_int,
    pub bottomMost: ::std::os::raw::c_int,
    pub neighborCount: ::std::os::raw::c_int,
    pub neighbors: [::std::os::raw::c_int; 256usize],
    pub isAccessible: bool,
    pub isHigherGround: bool,
}
#[test]
fn bindgen_test_layout_BWAPI_RegionData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_RegionData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_RegionData>(),
        1068usize,
        concat!("Size of: ", stringify!(BWAPI_RegionData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_RegionData>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_RegionData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).islandID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(islandID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(center_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(center_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftMost) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(leftMost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rightMost) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(rightMost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topMost) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(topMost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottomMost) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(bottomMost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighborCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(neighborCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighbors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(neighbors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isAccessible) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(isAccessible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isHigherGround) as usize - ptr as usize },
        1065usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionData),
            "::",
            stringify!(isHigherGround)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct BWAPI_UnitData {
    pub clearanceLevel: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub player: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub positionX: ::std::os::raw::c_int,
    pub positionY: ::std::os::raw::c_int,
    pub angle: f64,
    pub velocityX: f64,
    pub velocityY: f64,
    pub hitPoints: ::std::os::raw::c_int,
    pub lastHitPoints: ::std::os::raw::c_int,
    pub shields: ::std::os::raw::c_int,
    pub energy: ::std::os::raw::c_int,
    pub resources: ::std::os::raw::c_int,
    pub resourceGroup: ::std::os::raw::c_int,
    pub killCount: ::std::os::raw::c_int,
    pub acidSporeCount: ::std::os::raw::c_int,
    pub scarabCount: ::std::os::raw::c_int,
    pub interceptorCount: ::std::os::raw::c_int,
    pub spiderMineCount: ::std::os::raw::c_int,
    pub groundWeaponCooldown: ::std::os::raw::c_int,
    pub airWeaponCooldown: ::std::os::raw::c_int,
    pub spellCooldown: ::std::os::raw::c_int,
    pub defenseMatrixPoints: ::std::os::raw::c_int,
    pub defenseMatrixTimer: ::std::os::raw::c_int,
    pub ensnareTimer: ::std::os::raw::c_int,
    pub irradiateTimer: ::std::os::raw::c_int,
    pub lockdownTimer: ::std::os::raw::c_int,
    pub maelstromTimer: ::std::os::raw::c_int,
    pub orderTimer: ::std::os::raw::c_int,
    pub plagueTimer: ::std::os::raw::c_int,
    pub removeTimer: ::std::os::raw::c_int,
    pub stasisTimer: ::std::os::raw::c_int,
    pub stimTimer: ::std::os::raw::c_int,
    pub buildType: ::std::os::raw::c_int,
    pub trainingQueueCount: ::std::os::raw::c_int,
    pub trainingQueue: [::std::os::raw::c_int; 5usize],
    pub tech: ::std::os::raw::c_int,
    pub upgrade: ::std::os::raw::c_int,
    pub remainingBuildTime: ::std::os::raw::c_int,
    pub remainingTrainTime: ::std::os::raw::c_int,
    pub remainingResearchTime: ::std::os::raw::c_int,
    pub remainingUpgradeTime: ::std::os::raw::c_int,
    pub buildUnit: ::std::os::raw::c_int,
    pub target: ::std::os::raw::c_int,
    pub targetPositionX: ::std::os::raw::c_int,
    pub targetPositionY: ::std::os::raw::c_int,
    pub order: ::std::os::raw::c_int,
    pub orderTarget: ::std::os::raw::c_int,
    pub orderTargetPositionX: ::std::os::raw::c_int,
    pub orderTargetPositionY: ::std::os::raw::c_int,
    pub secondaryOrder: ::std::os::raw::c_int,
    pub rallyPositionX: ::std::os::raw::c_int,
    pub rallyPositionY: ::std::os::raw::c_int,
    pub rallyUnit: ::std::os::raw::c_int,
    pub addon: ::std::os::raw::c_int,
    pub nydusExit: ::std::os::raw::c_int,
    pub powerUp: ::std::os::raw::c_int,
    pub transport: ::std::os::raw::c_int,
    pub carrier: ::std::os::raw::c_int,
    pub hatchery: ::std::os::raw::c_int,
    pub exists: bool,
    pub hasNuke: bool,
    pub isAccelerating: bool,
    pub isAttacking: bool,
    pub isAttackFrame: bool,
    pub isBeingGathered: bool,
    pub isBlind: bool,
    pub isBraking: bool,
    pub isBurrowed: bool,
    pub carryResourceType: ::std::os::raw::c_int,
    pub isCloaked: bool,
    pub isCompleted: bool,
    pub isConstructing: bool,
    pub isDetected: bool,
    pub isGathering: bool,
    pub isHallucination: bool,
    pub isIdle: bool,
    pub isInterruptible: bool,
    pub isInvincible: bool,
    pub isLifted: bool,
    pub isMorphing: bool,
    pub isMoving: bool,
    pub isParasited: bool,
    pub isSelected: bool,
    pub isStartingAttack: bool,
    pub isStuck: bool,
    pub isTraining: bool,
    pub isUnderStorm: bool,
    pub isUnderDarkSwarm: bool,
    pub isUnderDWeb: bool,
    pub isPowered: bool,
    pub isVisible: [bool; 9usize],
    pub buttonset: ::std::os::raw::c_int,
    pub lastAttackerPlayer: ::std::os::raw::c_int,
    pub recentlyAttacked: bool,
    pub replayID: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_UnitData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitData>(),
        336usize,
        concat!("Size of: ", stringify!(BWAPI_UnitData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitData>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearanceLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(clearanceLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).player) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(player)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positionX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(positionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positionY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(positionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(velocityX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(velocityY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitPoints) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(hitPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastHitPoints) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(lastHitPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shields) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(shields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resources) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceGroup) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(resourceGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).killCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(killCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acidSporeCount) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(acidSporeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scarabCount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(scarabCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interceptorCount) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(interceptorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spiderMineCount) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(spiderMineCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).groundWeaponCooldown) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(groundWeaponCooldown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).airWeaponCooldown) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(airWeaponCooldown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spellCooldown) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(spellCooldown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defenseMatrixPoints) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(defenseMatrixPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defenseMatrixTimer) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(defenseMatrixTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ensnareTimer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(ensnareTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irradiateTimer) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(irradiateTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lockdownTimer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(lockdownTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maelstromTimer) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(maelstromTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orderTimer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(orderTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plagueTimer) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(plagueTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeTimer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(removeTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stasisTimer) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(stasisTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stimTimer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(stimTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buildType) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(buildType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trainingQueueCount) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(trainingQueueCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trainingQueue) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(trainingQueue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tech) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(tech)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upgrade) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(upgrade)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingBuildTime) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(remainingBuildTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingTrainTime) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(remainingTrainTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingResearchTime) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(remainingResearchTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingUpgradeTime) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(remainingUpgradeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buildUnit) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(buildUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetPositionX) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(targetPositionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetPositionY) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(targetPositionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orderTarget) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(orderTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orderTargetPositionX) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(orderTargetPositionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orderTargetPositionY) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(orderTargetPositionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secondaryOrder) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(secondaryOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rallyPositionX) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(rallyPositionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rallyPositionY) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(rallyPositionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rallyUnit) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(rallyUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addon) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(addon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nydusExit) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(nydusExit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).powerUp) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(powerUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).carrier) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(carrier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hatchery) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(hatchery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exists) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(exists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasNuke) as usize - ptr as usize },
        273usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(hasNuke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isAccelerating) as usize - ptr as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isAccelerating)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isAttacking) as usize - ptr as usize },
        275usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isAttacking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isAttackFrame) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isAttackFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBeingGathered) as usize - ptr as usize },
        277usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isBeingGathered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBlind) as usize - ptr as usize },
        278usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isBlind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBraking) as usize - ptr as usize },
        279usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isBraking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBurrowed) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isBurrowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).carryResourceType) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(carryResourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isCloaked) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isCloaked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isCompleted) as usize - ptr as usize },
        289usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isConstructing) as usize - ptr as usize },
        290usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isConstructing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDetected) as usize - ptr as usize },
        291usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isDetected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isGathering) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isGathering)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isHallucination) as usize - ptr as usize },
        293usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isHallucination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isIdle) as usize - ptr as usize },
        294usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isIdle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isInterruptible) as usize - ptr as usize },
        295usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isInterruptible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isInvincible) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isInvincible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isLifted) as usize - ptr as usize },
        297usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isLifted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMorphing) as usize - ptr as usize },
        298usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isMorphing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMoving) as usize - ptr as usize },
        299usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isMoving)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isParasited) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isParasited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isSelected) as usize - ptr as usize },
        301usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isSelected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isStartingAttack) as usize - ptr as usize },
        302usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isStartingAttack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isStuck) as usize - ptr as usize },
        303usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isStuck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isTraining) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isTraining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isUnderStorm) as usize - ptr as usize },
        305usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isUnderStorm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isUnderDarkSwarm) as usize - ptr as usize },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isUnderDarkSwarm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isUnderDWeb) as usize - ptr as usize },
        307usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isUnderDWeb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPowered) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isPowered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isVisible) as usize - ptr as usize },
        309usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(isVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonset) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(buttonset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastAttackerPlayer) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(lastAttackerPlayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recentlyAttacked) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(recentlyAttacked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayID) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitData),
            "::",
            stringify!(replayID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct BWAPI_BulletData {
    pub id: ::std::os::raw::c_int,
    pub player: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub source: ::std::os::raw::c_int,
    pub positionX: ::std::os::raw::c_int,
    pub positionY: ::std::os::raw::c_int,
    pub angle: f64,
    pub velocityX: f64,
    pub velocityY: f64,
    pub target: ::std::os::raw::c_int,
    pub targetPositionX: ::std::os::raw::c_int,
    pub targetPositionY: ::std::os::raw::c_int,
    pub removeTimer: ::std::os::raw::c_int,
    pub exists: bool,
    pub isVisible: [bool; 9usize],
}
#[test]
fn bindgen_test_layout_BWAPI_BulletData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_BulletData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_BulletData>(),
        80usize,
        concat!("Size of: ", stringify!(BWAPI_BulletData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_BulletData>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_BulletData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).player) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(player)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positionX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(positionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positionY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(positionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(velocityX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(velocityY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetPositionX) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(targetPositionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetPositionY) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(targetPositionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeTimer) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(removeTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exists) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(exists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isVisible) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletData),
            "::",
            stringify!(isVisible)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_unitFinder {
    pub unitIndex: ::std::os::raw::c_int,
    pub searchValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPI_unitFinder() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_unitFinder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_unitFinder>(),
        8usize,
        concat!("Size of: ", stringify!(BWAPI_unitFinder))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_unitFinder>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_unitFinder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_unitFinder),
            "::",
            stringify!(unitIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_unitFinder),
            "::",
            stringify!(searchValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct BWAPI_GameData {
    pub client_version: ::std::os::raw::c_int,
    pub revision: ::std::os::raw::c_int,
    pub isDebug: bool,
    pub instanceID: ::std::os::raw::c_int,
    pub botAPM_noselects: ::std::os::raw::c_int,
    pub botAPM_selects: ::std::os::raw::c_int,
    pub forceCount: ::std::os::raw::c_int,
    pub forces: [BWAPI_ForceData; 5usize],
    pub playerCount: ::std::os::raw::c_int,
    pub players: [BWAPI_PlayerData; 12usize],
    pub initialUnitCount: ::std::os::raw::c_int,
    pub units: [BWAPI_UnitData; 10000usize],
    pub unitArray: [::std::os::raw::c_int; 1700usize],
    pub bullets: [BWAPI_BulletData; 100usize],
    pub nukeDotCount: ::std::os::raw::c_int,
    pub nukeDots: [BWAPIC_Position; 200usize],
    pub gameType: ::std::os::raw::c_int,
    pub latency: ::std::os::raw::c_int,
    pub latencyFrames: ::std::os::raw::c_int,
    pub latencyTime: ::std::os::raw::c_int,
    pub remainingLatencyFrames: ::std::os::raw::c_int,
    pub remainingLatencyTime: ::std::os::raw::c_int,
    pub hasLatCom: bool,
    pub hasGUI: bool,
    pub replayFrameCount: ::std::os::raw::c_int,
    pub randomSeed: ::std::os::raw::c_uint,
    pub frameCount: ::std::os::raw::c_int,
    pub elapsedTime: ::std::os::raw::c_int,
    pub countdownTimer: ::std::os::raw::c_int,
    pub fps: ::std::os::raw::c_int,
    pub averageFPS: f64,
    pub mouseX: ::std::os::raw::c_int,
    pub mouseY: ::std::os::raw::c_int,
    pub mouseState: [bool; 3usize],
    pub keyState: [bool; 255usize],
    pub screenX: ::std::os::raw::c_int,
    pub screenY: ::std::os::raw::c_int,
    pub flags: [bool; 2usize],
    pub mapWidth: ::std::os::raw::c_int,
    pub mapHeight: ::std::os::raw::c_int,
    pub mapFileName: [::std::os::raw::c_char; 261usize],
    pub mapPathName: [::std::os::raw::c_char; 261usize],
    pub mapName: [::std::os::raw::c_char; 33usize],
    pub mapHash: [::std::os::raw::c_char; 41usize],
    pub getGroundHeight: [[::std::os::raw::c_int; 256usize]; 256usize],
    pub isWalkable: [[bool; 1024usize]; 1024usize],
    pub isBuildable: [[bool; 256usize]; 256usize],
    pub isVisible: [[bool; 256usize]; 256usize],
    pub isExplored: [[bool; 256usize]; 256usize],
    pub hasCreep: [[bool; 256usize]; 256usize],
    pub isOccupied: [[bool; 256usize]; 256usize],
    pub mapTileRegionId: [[::std::os::raw::c_ushort; 256usize]; 256usize],
    pub mapSplitTilesMiniTileMask: [::std::os::raw::c_ushort; 5000usize],
    pub mapSplitTilesRegion1: [::std::os::raw::c_ushort; 5000usize],
    pub mapSplitTilesRegion2: [::std::os::raw::c_ushort; 5000usize],
    pub regionCount: ::std::os::raw::c_int,
    pub regions: [BWAPI_RegionData; 5000usize],
    pub startLocationCount: ::std::os::raw::c_int,
    pub startLocations: [BWAPIC_Position; 8usize],
    pub isInGame: bool,
    pub isMultiplayer: bool,
    pub isBattleNet: bool,
    pub isPaused: bool,
    pub isReplay: bool,
    pub selectedUnitCount: ::std::os::raw::c_int,
    pub selectedUnits: [::std::os::raw::c_int; 12usize],
    pub self_: ::std::os::raw::c_int,
    pub enemy: ::std::os::raw::c_int,
    pub neutral: ::std::os::raw::c_int,
    pub eventCount: ::std::os::raw::c_int,
    pub events: [BWAPIC_Event; 10000usize],
    pub eventStringCount: ::std::os::raw::c_int,
    pub eventStrings: [[::std::os::raw::c_char; 256usize]; 1000usize],
    pub stringCount: ::std::os::raw::c_int,
    pub strings: [[::std::os::raw::c_char; 1024usize]; 20000usize],
    pub shapeCount: ::std::os::raw::c_int,
    pub shapes: [BWAPIC_Shape; 20000usize],
    pub commandCount: ::std::os::raw::c_int,
    pub commands: [BWAPIC_Command; 20000usize],
    pub unitCommandCount: ::std::os::raw::c_int,
    pub unitCommands: [BWAPIC_UnitCommand; 20000usize],
    pub unitSearchSize: ::std::os::raw::c_int,
    pub xUnitSearch: [BWAPI_unitFinder; 3400usize],
    pub yUnitSearch: [BWAPI_unitFinder; 3400usize],
}
pub const BWAPI_GameData_MAX_EVENTS: ::std::os::raw::c_int = 10000;
pub const BWAPI_GameData_MAX_EVENT_STRINGS: ::std::os::raw::c_int = 1000;
pub const BWAPI_GameData_MAX_STRINGS: ::std::os::raw::c_int = 20000;
pub const BWAPI_GameData_MAX_SHAPES: ::std::os::raw::c_int = 20000;
pub const BWAPI_GameData_MAX_COMMANDS: ::std::os::raw::c_int = 20000;
pub const BWAPI_GameData_MAX_UNIT_COMMANDS: ::std::os::raw::c_int = 20000;
#[test]
fn bindgen_test_layout_BWAPI_GameData() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_GameData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameData>(),
        33017048usize,
        concat!("Size of: ", stringify!(BWAPI_GameData))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameData>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_GameData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(client_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDebug) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instanceID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(instanceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).botAPM_noselects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(botAPM_noselects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).botAPM_selects) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(botAPM_selects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(forceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forces) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(forces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playerCount) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(playerCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).players) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(players)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialUnitCount) as usize - ptr as usize },
        69648usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(initialUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        69656usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitArray) as usize - ptr as usize },
        3429656usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(unitArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bullets) as usize - ptr as usize },
        3436456usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(bullets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nukeDotCount) as usize - ptr as usize },
        3444456usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(nukeDotCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nukeDots) as usize - ptr as usize },
        3444460usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(nukeDots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameType) as usize - ptr as usize },
        3446060usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(gameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        3446064usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latencyFrames) as usize - ptr as usize },
        3446068usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(latencyFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latencyTime) as usize - ptr as usize },
        3446072usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(latencyTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingLatencyFrames) as usize - ptr as usize },
        3446076usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(remainingLatencyFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingLatencyTime) as usize - ptr as usize },
        3446080usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(remainingLatencyTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasLatCom) as usize - ptr as usize },
        3446084usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(hasLatCom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasGUI) as usize - ptr as usize },
        3446085usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(hasGUI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayFrameCount) as usize - ptr as usize },
        3446088usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(replayFrameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).randomSeed) as usize - ptr as usize },
        3446092usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(randomSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameCount) as usize - ptr as usize },
        3446096usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(frameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elapsedTime) as usize - ptr as usize },
        3446100usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(elapsedTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).countdownTimer) as usize - ptr as usize },
        3446104usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(countdownTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        3446108usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageFPS) as usize - ptr as usize },
        3446112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(averageFPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouseX) as usize - ptr as usize },
        3446120usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mouseX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouseY) as usize - ptr as usize },
        3446124usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mouseY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouseState) as usize - ptr as usize },
        3446128usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mouseState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyState) as usize - ptr as usize },
        3446131usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(keyState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screenX) as usize - ptr as usize },
        3446388usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(screenX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screenY) as usize - ptr as usize },
        3446392usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(screenY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        3446396usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapWidth) as usize - ptr as usize },
        3446400usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapHeight) as usize - ptr as usize },
        3446404usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapFileName) as usize - ptr as usize },
        3446408usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapPathName) as usize - ptr as usize },
        3446669usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapPathName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapName) as usize - ptr as usize },
        3446930usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapHash) as usize - ptr as usize },
        3446963usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getGroundHeight) as usize - ptr as usize },
        3447004usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(getGroundHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isWalkable) as usize - ptr as usize },
        3709148usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isWalkable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBuildable) as usize - ptr as usize },
        4757724usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isBuildable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isVisible) as usize - ptr as usize },
        4823260usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isExplored) as usize - ptr as usize },
        4888796usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isExplored)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasCreep) as usize - ptr as usize },
        4954332usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(hasCreep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isOccupied) as usize - ptr as usize },
        5019868usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isOccupied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapTileRegionId) as usize - ptr as usize },
        5085404usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapTileRegionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapSplitTilesMiniTileMask) as usize - ptr as usize },
        5216476usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapSplitTilesMiniTileMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapSplitTilesRegion1) as usize - ptr as usize },
        5226476usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapSplitTilesRegion1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapSplitTilesRegion2) as usize - ptr as usize },
        5236476usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(mapSplitTilesRegion2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize },
        5246476usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(regionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regions) as usize - ptr as usize },
        5246480usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startLocationCount) as usize - ptr as usize },
        10586480usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(startLocationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startLocations) as usize - ptr as usize },
        10586484usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(startLocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isInGame) as usize - ptr as usize },
        10586548usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isInGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultiplayer) as usize - ptr as usize },
        10586549usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isMultiplayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isBattleNet) as usize - ptr as usize },
        10586550usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isBattleNet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPaused) as usize - ptr as usize },
        10586551usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isPaused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isReplay) as usize - ptr as usize },
        10586552usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(isReplay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selectedUnitCount) as usize - ptr as usize },
        10586556usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(selectedUnitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selectedUnits) as usize - ptr as usize },
        10586560usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(selectedUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        10586608usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enemy) as usize - ptr as usize },
        10586612usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(enemy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neutral) as usize - ptr as usize },
        10586616usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(neutral)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventCount) as usize - ptr as usize },
        10586620usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(eventCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        10586624usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventStringCount) as usize - ptr as usize },
        10706624usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(eventStringCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventStrings) as usize - ptr as usize },
        10706628usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(eventStrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringCount) as usize - ptr as usize },
        10962628usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(stringCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        10962632usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shapeCount) as usize - ptr as usize },
        31442632usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(shapeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shapes) as usize - ptr as usize },
        31442636usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(shapes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandCount) as usize - ptr as usize },
        32242636usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(commandCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commands) as usize - ptr as usize },
        32242640usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(commands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitCommandCount) as usize - ptr as usize },
        32482640usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(unitCommandCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitCommands) as usize - ptr as usize },
        32482644usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(unitCommands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitSearchSize) as usize - ptr as usize },
        32962644usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(unitSearchSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xUnitSearch) as usize - ptr as usize },
        32962648usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(xUnitSearch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yUnitSearch) as usize - ptr as usize },
        32989848usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameData),
            "::",
            stringify!(yUnitSearch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_ForceImpl {
    pub _base: BWAPI_ForceInterface,
    pub self_: *const BWAPI_ForceData,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPI_ForceImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_ForceImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_ForceImpl>(),
        96usize,
        concat!("Size of: ", stringify!(BWAPI_ForceImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_ForceImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_ForceImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_ForceImpl),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_ForceImpl),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI9ForceImplC1Ei"]
    pub fn BWAPI_ForceImpl_ForceImpl(this: *mut BWAPI_ForceImpl, id: ::std::os::raw::c_int);
}
impl BWAPI_ForceImpl {
    #[inline]
    pub unsafe fn new(id: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_ForceImpl_ForceImpl(__bindgen_tmp.as_mut_ptr(), id);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_PlayerImpl {
    pub _base: BWAPI_PlayerInterface,
    pub id: ::std::os::raw::c_int,
    pub self_: *mut BWAPI_PlayerData,
    pub units: BWAPI_Unitset,
}
#[test]
fn bindgen_test_layout_BWAPI_PlayerImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_PlayerImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_PlayerImpl>(),
        152usize,
        concat!("Size of: ", stringify!(BWAPI_PlayerImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_PlayerImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_PlayerImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerImpl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerImpl),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_PlayerImpl),
            "::",
            stringify!(units)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI10PlayerImplC1Ei"]
    pub fn BWAPI_PlayerImpl_PlayerImpl(this: *mut BWAPI_PlayerImpl, id: ::std::os::raw::c_int);
}
impl BWAPI_PlayerImpl {
    #[inline]
    pub unsafe fn new(id: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_PlayerImpl_PlayerImpl(__bindgen_tmp.as_mut_ptr(), id);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_RegionImpl {
    pub _base: BWAPI_RegionInterface,
    pub self_: *mut BWAPI_RegionData,
    pub neighbors: BWAPI_Regionset,
    pub closestAccessibleRgn: BWAPI_Region,
    pub closestInaccessibleRgn: BWAPI_Region,
}
#[test]
fn bindgen_test_layout_BWAPI_RegionImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_RegionImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_RegionImpl>(),
        160usize,
        concat!("Size of: ", stringify!(BWAPI_RegionImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_RegionImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_RegionImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionImpl),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighbors) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionImpl),
            "::",
            stringify!(neighbors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closestAccessibleRgn) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionImpl),
            "::",
            stringify!(closestAccessibleRgn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closestInaccessibleRgn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_RegionImpl),
            "::",
            stringify!(closestInaccessibleRgn)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI10RegionImplC1Ei"]
    pub fn BWAPI_RegionImpl_RegionImpl(this: *mut BWAPI_RegionImpl, index: ::std::os::raw::c_int);
}
impl BWAPI_RegionImpl {
    #[inline]
    pub unsafe fn new(index: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_RegionImpl_RegionImpl(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_UnitImpl {
    pub _base: BWAPI_UnitInterface,
    pub id: ::std::os::raw::c_int,
    pub initialType: BWAPI_UnitType,
    pub initialResources: ::std::os::raw::c_int,
    pub initialHitPoints: ::std::os::raw::c_int,
    pub initialPosition: BWAPI_Position,
    pub lastCommandFrame: ::std::os::raw::c_int,
    pub lastCommand: BWAPI_UnitCommand,
    pub self_: *mut BWAPI_UnitData,
    pub connectedUnits: BWAPI_Unitset,
    pub loadedUnits: BWAPI_Unitset,
}
#[test]
fn bindgen_test_layout_BWAPI_UnitImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_UnitImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_UnitImpl>(),
        272usize,
        concat!("Size of: ", stringify!(BWAPI_UnitImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_UnitImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_UnitImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialType) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(initialType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialResources) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(initialResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialHitPoints) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(initialHitPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialPosition) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(initialPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastCommandFrame) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(lastCommandFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastCommand) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(lastCommand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connectedUnits) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(connectedUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loadedUnits) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_UnitImpl),
            "::",
            stringify!(loadedUnits)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI8UnitImplC1Ei"]
    pub fn BWAPI_UnitImpl_UnitImpl(this: *mut BWAPI_UnitImpl, _id: ::std::os::raw::c_int);
}
impl BWAPI_UnitImpl {
    #[inline]
    pub unsafe fn new(_id: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_UnitImpl_UnitImpl(__bindgen_tmp.as_mut_ptr(), _id);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_BulletImpl {
    pub _base: BWAPI_BulletInterface,
    pub self_: *const BWAPI_BulletData,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPI_BulletImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_BulletImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_BulletImpl>(),
        96usize,
        concat!("Size of: ", stringify!(BWAPI_BulletImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_BulletImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_BulletImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletImpl),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_BulletImpl),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI10BulletImplC1Ei"]
    pub fn BWAPI_BulletImpl_BulletImpl(this: *mut BWAPI_BulletImpl, index: ::std::os::raw::c_int);
}
impl BWAPI_BulletImpl {
    #[inline]
    pub unsafe fn new(index: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_BulletImpl_BulletImpl(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct BWAPI_GameImpl {
    pub _base: BWAPI_Game,
    pub data: *mut BWAPI_GameData,
    pub forceVector: [u64; 3usize],
    pub playerVector: [u64; 3usize],
    pub unitVector: [u64; 3usize],
    pub bulletVector: [u64; 3usize],
    pub regionArray: [u64; 5000usize],
    pub forces: BWAPI_Forceset,
    pub playerSet: BWAPI_Playerset,
    pub accessibleUnits: BWAPI_Unitset,
    pub minerals: BWAPI_Unitset,
    pub geysers: BWAPI_Unitset,
    pub neutralUnits: BWAPI_Unitset,
    pub staticMinerals: BWAPI_Unitset,
    pub staticGeysers: BWAPI_Unitset,
    pub staticNeutralUnits: BWAPI_Unitset,
    pub bullets: BWAPI_Bulletset,
    pub nukeDots: [u64; 10usize],
    pub selectedUnits: BWAPI_Unitset,
    pub pylons: BWAPI_Unitset,
    pub regionsList: BWAPI_Regionset,
    pub startLocations: [u64; 10usize],
    pub events: [u64; 3usize],
    pub thePlayer: BWAPI_Player,
    pub theEnemy: BWAPI_Player,
    pub theNeutral: BWAPI_Player,
    pub _allies: BWAPI_Playerset,
    pub _enemies: BWAPI_Playerset,
    pub _observers: BWAPI_Playerset,
    pub lastError: BWAPI_Error,
    pub textSize: BWAPI_Text_Size_Enum,
    pub inGame: bool,
}
#[test]
fn bindgen_test_layout_BWAPI_GameImpl() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_GameImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameImpl>(),
        41304usize,
        concat!("Size of: ", stringify!(BWAPI_GameImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_GameImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceVector) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(forceVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playerVector) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(playerVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitVector) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(unitVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bulletVector) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(bulletVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regionArray) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(regionArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forces) as usize - ptr as usize },
        40184usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(forces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playerSet) as usize - ptr as usize },
        40240usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(playerSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessibleUnits) as usize - ptr as usize },
        40296usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(accessibleUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minerals) as usize - ptr as usize },
        40352usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(minerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geysers) as usize - ptr as usize },
        40408usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(geysers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neutralUnits) as usize - ptr as usize },
        40464usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(neutralUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticMinerals) as usize - ptr as usize },
        40520usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(staticMinerals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticGeysers) as usize - ptr as usize },
        40576usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(staticGeysers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticNeutralUnits) as usize - ptr as usize },
        40632usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(staticNeutralUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bullets) as usize - ptr as usize },
        40688usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(bullets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nukeDots) as usize - ptr as usize },
        40744usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(nukeDots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selectedUnits) as usize - ptr as usize },
        40824usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(selectedUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pylons) as usize - ptr as usize },
        40880usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(pylons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regionsList) as usize - ptr as usize },
        40936usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(regionsList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startLocations) as usize - ptr as usize },
        40992usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(startLocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        41072usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thePlayer) as usize - ptr as usize },
        41096usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(thePlayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theEnemy) as usize - ptr as usize },
        41104usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(theEnemy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theNeutral) as usize - ptr as usize },
        41112usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(theNeutral)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._allies) as usize - ptr as usize },
        41120usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(_allies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._enemies) as usize - ptr as usize },
        41176usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(_enemies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._observers) as usize - ptr as usize },
        41232usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(_observers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastError) as usize - ptr as usize },
        41288usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(lastError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textSize) as usize - ptr as usize },
        41292usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(textSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inGame) as usize - ptr as usize },
        41296usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameImpl),
            "::",
            stringify!(inGame)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI8GameImplC1EPNS_8GameDataE"]
    pub fn BWAPI_GameImpl_GameImpl(this: *mut BWAPI_GameImpl, data: *mut BWAPI_GameData);
}
impl BWAPI_GameImpl {
    #[inline]
    pub unsafe fn new(data: *mut BWAPI_GameData) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_GameImpl_GameImpl(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_GameInstance {
    pub serverProcessID: ::std::os::raw::c_uint,
    pub isConnected: bool,
    pub lastKeepAliveTime: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_BWAPI_GameInstance() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_GameInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameInstance>(),
        12usize,
        concat!("Size of: ", stringify!(BWAPI_GameInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameInstance>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_GameInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverProcessID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameInstance),
            "::",
            stringify!(serverProcessID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isConnected) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameInstance),
            "::",
            stringify!(isConnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastKeepAliveTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameInstance),
            "::",
            stringify!(lastKeepAliveTime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPI_GameTable {
    pub gameInstances: [BWAPI_GameInstance; 8usize],
}
pub const BWAPI_GameTable_MAX_GAME_INSTANCES: ::std::os::raw::c_int = 8;
#[test]
fn bindgen_test_layout_BWAPI_GameTable() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_GameTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_GameTable>(),
        96usize,
        concat!("Size of: ", stringify!(BWAPI_GameTable))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_GameTable>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPI_GameTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameInstances) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_GameTable),
            "::",
            stringify!(gameInstances)
        )
    );
}
#[repr(C)]
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct BWAPI_Client {
    pub data: *mut BWAPI_GameData,
    pub pipeObjectHandle: HANDLE,
    pub mapFileHandle: HANDLE,
    pub gameTableFileHandle: HANDLE,
    pub gameTable: *mut BWAPI_GameTable,
    pub connected: bool,
}
#[test]
fn bindgen_test_layout_BWAPI_Client() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPI_Client> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Client>(),
        48usize,
        concat!("Size of: ", stringify!(BWAPI_Client))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Client>(),
        8usize,
        concat!("Alignment of ", stringify!(BWAPI_Client))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeObjectHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(pipeObjectHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapFileHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(mapFileHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameTableFileHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(gameTableFileHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameTable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(gameTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPI_Client),
            "::",
            stringify!(connected)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI6ClientC1Ev"]
    pub fn BWAPI_Client_Client(this: *mut BWAPI_Client);
}
extern "C" {
    #[link_name = "\u{1}_ZN5BWAPI6ClientD1Ev"]
    pub fn BWAPI_Client_Client_destructor(this: *mut BWAPI_Client);
}
impl BWAPI_Client {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BWAPI_Client_Client(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        BWAPI_Client_Client_destructor(self)
    }
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPIC_UnitCommand {
    pub type_: BWAPI_UnitCommandType,
    pub unitIndex: ::std::os::raw::c_int,
    pub targetIndex: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub extra: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPIC_UnitCommand() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPIC_UnitCommand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPIC_UnitCommand>(),
        24usize,
        concat!("Size of: ", stringify!(BWAPIC_UnitCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPIC_UnitCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPIC_UnitCommand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unitIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(unitIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(targetIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_UnitCommand),
            "::",
            stringify!(extra)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPIC_Event {
    pub type_: BWAPI_EventType_Enum,
    pub v1: ::std::os::raw::c_int,
    pub v2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPIC_Event() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPIC_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPIC_Event>(),
        12usize,
        concat!("Size of: ", stringify!(BWAPIC_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPIC_Event>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPIC_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Event),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Event),
            "::",
            stringify!(v2)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPIC_CommandType_Enum {
    None = 0,
    SetScreenPosition = 1,
    PingMinimap = 2,
    EnableFlag = 3,
    Printf = 4,
    SendText = 5,
    PauseGame = 6,
    ResumeGame = 7,
    LeaveGame = 8,
    RestartGame = 9,
    SetLocalSpeed = 10,
    SetLatCom = 11,
    SetGui = 12,
    SetFrameSkip = 13,
    SetMap = 14,
    SetAllies = 15,
    SetVision = 16,
    SetCommandOptimizerLevel = 17,
    SetRevealAll = 18,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPIC_Command {
    pub type_: BWAPIC_CommandType_Enum,
    pub value1: ::std::os::raw::c_int,
    pub value2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPIC_Command() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPIC_Command> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPIC_Command>(),
        12usize,
        concat!("Size of: ", stringify!(BWAPIC_Command))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPIC_Command>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPIC_Command))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Command),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Command),
            "::",
            stringify!(value1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Command),
            "::",
            stringify!(value2)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, FromPrimitive)]
pub enum BWAPIC_ShapeType_Enum {
    None = 0,
    Text = 1,
    Box = 2,
    Triangle = 3,
    Circle = 4,
    Ellipse = 5,
    Dot = 6,
    Line = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPIC_Shape {
    pub type_: BWAPIC_ShapeType_Enum,
    pub ctype: BWAPI_CoordinateType_Enum,
    pub x1: ::std::os::raw::c_int,
    pub y1: ::std::os::raw::c_int,
    pub x2: ::std::os::raw::c_int,
    pub y2: ::std::os::raw::c_int,
    pub extra1: ::std::os::raw::c_int,
    pub extra2: ::std::os::raw::c_int,
    pub color: ::std::os::raw::c_int,
    pub isSolid: bool,
}
#[test]
fn bindgen_test_layout_BWAPIC_Shape() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPIC_Shape> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPIC_Shape>(),
        40usize,
        concat!("Size of: ", stringify!(BWAPIC_Shape))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPIC_Shape>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPIC_Shape))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isSolid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Shape),
            "::",
            stringify!(isSolid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BWAPIC_Position {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BWAPIC_Position() {
    const UNINIT: ::std::mem::MaybeUninit<BWAPIC_Position> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BWAPIC_Position>(),
        8usize,
        concat!("Size of: ", stringify!(BWAPIC_Position))
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPIC_Position>(),
        4usize,
        concat!("Alignment of ", stringify!(BWAPIC_Position))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Position),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BWAPIC_Position),
            "::",
            stringify!(y)
        )
    );
}
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_UnaryFilter_open0_BWAPI_Unit__bindgen_ty_id_84808_open1__bindgen_ty_id_84803_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 4usize]>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 4usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_UnitInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_BulletInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_SetContainer_open0_BWAPI_Bullet__bindgen_ty_id_84952_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_SetContainer>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_SetContainer>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_ForceInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_SetContainer_open0_BWAPI_Force__bindgen_ty_id_85067_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_SetContainer>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_SetContainer>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_Game_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_PlayerInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_SetContainer_open0_BWAPI_Player__bindgen_ty_id_85403_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_SetContainer>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_SetContainer>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_Interface_open0_BWAPI_RegionInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_Interface>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_Interface>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_Interface)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_SetContainer_open0_BWAPI_Region__bindgen_ty_id_85442_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_SetContainer>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_SetContainer>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
}
#[test]
fn __bindgen_test_layout_BWAPI_SetContainer_open0_BWAPI_Unit__bindgen_ty_id_85556_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<BWAPI_SetContainer>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BWAPI_SetContainer>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(BWAPI_SetContainer)
        )
    );
}
